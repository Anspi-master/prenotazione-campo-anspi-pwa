<script> 
let bookings = [],
    calendarBookings = [],
    selectedEvent = '',
    currentBooking = {},
    isAdminLoggedIn = false;
let currentAdminEmail = '';
let calendarDate = new Date();
let archivedBookings = [],
    archiveCalendarDate = new Date();
const ICONS = {
    calcetto: '‚öΩ',
    pallavolo: 'üèê',
    compleanno: 'üéâ',
    eventi: 'üé™',
    cliente: 'üë§',
    email: 'üìß',
    telefono: 'üìû',
    evento: 'üéØ',
    campo: 'üèüÔ∏è',
    data: 'üìÖ',
    ora: 'üïê',
    note: 'üìù',
    codice: 'üîê',
    timestamp: 'üïí'
};
let currentStatusFilter = 'tutti';
let passwordTimeout = null;

let cache = {
    bookings: null,
    timestamp: null,
    duration: 30000
};
window.onload = initializeApp;

function initializeApp() {
    if (typeof google !== 'undefined' && google.script && google.script.run) {
        console.log("Google Script API ready.");
        const today = new Date();
        document.getElementById('data').setAttribute('min', today.toISOString().split('T')[0]);
        document.getElementById('adminData').setAttribute('min', today.toISOString().split('T')[0]);

        setupEventListeners();
        loadInitialData();
        resetForm();
        injectCheckboxCSS();
        checkForResetToken();
        // Aggiunta la chiamata alla nuova funzione di setup per le ricorrenze
        setupSmartRecurringListeners();
        
        // Nasconde il loading screen mobile
        hideMobileLoading();
    } else {
        setTimeout(initializeApp, 150);
    }
}

// Gestione loading screen mobile
function hideMobileLoading() {
    const loadingScreen = document.getElementById('mobileLoading');
    if (loadingScreen) {
        setTimeout(() => {
            loadingScreen.classList.add('hidden');
            setTimeout(() => {
                loadingScreen.style.display = 'none';
            }, 300);
        }, 500);
    }
}

// Mostra loading screen mobile
function showMobileLoading() {
    const loadingScreen = document.getElementById('mobileLoading');
    if (loadingScreen) {
        loadingScreen.style.display = 'flex';
        loadingScreen.classList.remove('hidden');
    }
}


function updateStatus(message, online) {
    const indicator = document.getElementById('statusIndicator');
    indicator.textContent = online ? 'üü¢ ' + message : 'üî¥ ' + message;
    indicator.className = 'status-indicator ' + (online ? '' : 'offline');
}

function setupEventListeners() {
    document.getElementById('event-calcetto').addEventListener('click', () => selectEvent('calcetto'));
    document.getElementById('event-pallavolo').addEventListener('click', () => selectEvent('pallavolo'));
    document.getElementById('event-compleanno').addEventListener('click', () => selectEvent('compleanno'));
    document.getElementById('event-eventi').addEventListener('click', () => selectEvent('eventi'));
    document.getElementById('btn-back').addEventListener('click', resetForm);
    document.getElementById('btn-submit-booking').addEventListener('click', submitBooking);
    document.getElementById('btn-cancel-booking').addEventListener('click', cancelBooking);
    document.getElementById('btn-admin-login').addEventListener('click', adminLogin);
    document.getElementById('btn-admin-exit').addEventListener('click', exitAdminPanel);
    document.getElementById('btn-refresh-data').addEventListener('click', refreshData);
    document.getElementById('prevArchiveMonthBtn').addEventListener('click', () => {
        const currentMonth = archiveCalendarDate.getMonth();
        const currentYear = archiveCalendarDate.getFullYear();
        archiveCalendarDate = new Date(currentYear, currentMonth - 1, 1);
        renderArchivedMonthlyCalendar();
    });
    document.getElementById('nextArchiveMonthBtn').addEventListener('click', () => {
        const currentMonth = archiveCalendarDate.getMonth();
        const currentYear = archiveCalendarDate.getFullYear();
        archiveCalendarDate = new Date(currentYear, currentMonth + 1, 1);
        renderArchivedMonthlyCalendar();
    });
    const testArchiveBtn = document.getElementById('btn-test-archive');
    if (testArchiveBtn) {
        testArchiveBtn.addEventListener('click', testArchive);
    }

    const manualArchiveBtn = document.getElementById('btn-manual-archive');
    if (manualArchiveBtn) {
        manualArchiveBtn.addEventListener('click', manualArchive);
    }


    document.getElementById('admin-tabs-container').addEventListener('click', async (event) => {
        if (event.target.classList.contains('admin-tab') && event.target.dataset.tab) {
            await showAdminTab(event.target.dataset.tab);
        }
    });
    document.getElementById('adminEvento').addEventListener('change', toggleAdminCampoSelection);
    document.getElementById('btn-admin-submit-booking').addEventListener('click', submitAdminBooking);
    document.getElementById('prevMonthBtn').addEventListener('click', () => {
        const currentMonth = calendarDate.getMonth();
        const currentYear = calendarDate.getFullYear();
        calendarDate = new Date(currentYear, currentMonth - 1, 1);
        renderMonthlyCalendar();
    });
    document.getElementById('nextMonthBtn').addEventListener('click', () => {
        const currentMonth = calendarDate.getMonth();
        const currentYear = calendarDate.getFullYear();
        calendarDate = new Date(currentYear, currentMonth + 1, 1);
        renderMonthlyCalendar();
    });
    document.getElementById('prevWeekBtn').addEventListener('click', () => {
        calendarDate.setDate(calendarDate.getDate() - 7);
        renderWeeklyCalendar();
    });
    document.getElementById('nextWeekBtn').addEventListener('click', () => {
        calendarDate.setDate(calendarDate.getDate() + 7);
        renderWeeklyCalendar();
    });
    document.getElementById('btn-view-monthly').addEventListener('click', () => toggleCalendarView('monthly'));
    document.getElementById('btn-view-weekly').addEventListener('click', () => toggleCalendarView('weekly'));
    document.getElementById('close-confirm-modal').addEventListener('click', () => closeModal('confirmModal'));
    document.getElementById('btn-cancel-final-booking').addEventListener('click', () => closeModal('confirmModal'));
    document.getElementById('close-details-modal').addEventListener('click', () => closeModal('details-modal'));
    document.getElementById('calendarDays').addEventListener('click', (e) => {
        const dayCell = e.target.closest('.calendar-day');
        if (dayCell) {
            const dateString = dayCell.dataset.date;
            if (!dateString) return;
            const eventsForDay = getEventsForDate(dateString);
            if (eventsForDay.length > 0 && !e.target.closest('.monthly-event-bar')) {
                showDaySummaryModal(dateString, eventsForDay);
            }
        }
    });
    document.getElementById('password-toggle').addEventListener('click', togglePasswordVisibility);
    document.getElementById('loginPassword').addEventListener('input', handlePasswordInput);
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            document.querySelectorAll('.modal').forEach(m => m.style.display = 'none');
        }
    });
    // ‚úÖ Event listener rimosso - ora gestito centralmente in AdminUtils.txt
    document.querySelector('.status-filters').addEventListener('click', (e) => {
        if (e.target.classList.contains('filter-btn')) {
            const filter = e.target.dataset.filter;
            setStatusFilter(filter);
        }
    });
    const eventiSpecialiTbody = document.getElementById("eventiSpecialiTableBody");
    if (eventiSpecialiTbody) {
        eventiSpecialiTbody.addEventListener('click', (e) => {
            const button = e.target.closest('button');
            if (!button) return;
            const bookingId = button.dataset.id;
            if (button.classList.contains('approve-btn')) approveEvent(bookingId);
            else
            if (button.classList.contains('reject-btn')) rejectEvent(bookingId);
            else if (button.classList.contains('admin-delete-btn')) deleteBooking(bookingId);
        });
    }

    const bookingsTbody = document.getElementById("bookingsTableBody");
    if (bookingsTbody) {
        bookingsTbody.addEventListener('click', e => {
            if (e.target.classList.contains('admin-delete-btn')) deleteBooking(e.target.dataset.id);
        });
        bookingsTbody.addEventListener('change', e => {
            if (e.target.classList.contains('admin-ricorrente-check')) updateRecurring(e.target.dataset.id, e.target);
            if (e.target.classList.contains('admin-campo-select')) updateField(e.target.dataset.id, e.target);
        });
    }

    const closeArchiveModal = document.getElementById('close-archive-modal');
    if (closeArchiveModal) {
        closeArchiveModal.addEventListener('click', () => closeModal('archiveModal'));
    }

    const testDateMathBtn = document.getElementById('btn-test-date-math');
    if (testDateMathBtn) {
        testDateMathBtn.addEventListener('click', testDateMathBtnClick);
    }
    
    // === EVENT LISTENERS GESTIONE ADMIN ===
    const btnAddAdmin = document.getElementById('btn-add-admin');
    if (btnAddAdmin) {
        btnAddAdmin.addEventListener('click', addNewAdminHandler);
    }
    
    const btnResetPassword = document.getElementById('btn-reset-password');
    if (btnResetPassword) {
        btnResetPassword.addEventListener('click', resetAdminPasswordHandler);
    }
    
    const btnRemoveAdmin = document.getElementById('btn-remove-admin');
    if (btnRemoveAdmin) {
        btnRemoveAdmin.addEventListener('click', removeAdminHandler);
    }
    // Setup calendario pubblico
document.addEventListener('DOMContentLoaded', function() {
    if (document.getElementById('publicCalendar')) {
        setupPublicCalendarListeners();
    }
});
}
// Funzione per gestire doppio click sui giorni del calendario
function setupCalendarDoubleClick() {
    const calendarDays = document.getElementById('calendarDays');
    if (calendarDays) {
        calendarDays.addEventListener('dblclick', function(e) {
            // Verifica che sia un admin loggato
            if (!isAdminLoggedIn) {
                showBanner('‚ö†Ô∏è Solo gli admin possono creare eventi dal calendario', 'warning');
                return;
            }
            
            // Trova la cella del giorno
            const dayCell = e.target.closest('.calendar-day');
            if (!dayCell || dayCell.classList.contains('other-month')) return;
            
            const dateString = dayCell.dataset.date;
            if (!dateString) return;
            
            // Evita doppio click su eventi esistenti
            if (e.target.closest('.monthly-event-bar')) return;
            
            // Apri il form di creazione con la data precompilata
            openQuickBookingForm(dateString);
        });
    }
}
function addCalendarTooltips() {
    // Funzione placeholder per i tooltip del calendario
    // Puoi implementarla in seguito se necessario
    console.log('Tooltip calendario inizializzati');
}

// Funzione per aprire form rapido di prenotazione
function openQuickBookingForm(dateString) {
    // Vai al tab "Nuova Prenotazione"
    showAdminTab('new-booking');
    
    // Precompila la data
    const adminDataInput = document.getElementById('adminData');
    if (adminDataInput) {
        adminDataInput.value = dateString;
    }
    
    // Focus sul primo campo
    const adminNomeInput = document.getElementById('adminNome');
    if (adminNomeInput) {
        adminNomeInput.focus();
    }
    
    // Mostra messaggio
    showBanner(`üìÖ Nuova prenotazione per ${formatDate(dateString)}`, 'info', 3000);
}

// ‚úÖ FUNZIONE: Richiesta reset password (semplice)
function showPasswordResetForm() {
    const email = document.getElementById('loginEmail').value;
    
    if (!email) {
        showBanner('‚ùå Inserisci prima la tua email amministratore', 'error');
        return;
    }
    
    // Mostra modal con form
    const modal = document.getElementById('resetPasswordModal');
    const title = document.getElementById('resetModalTitle');
    const content = document.getElementById('resetContent');
    const footer = document.getElementById('resetFooter');

    title.textContent = 'üîë Richiesta Reset Password';
    content.innerHTML = `
        <p>Inserisci la tua email da amministratore. Ti invieremo un link per reimpostare la password.</p>
        <div class="form-group" style="margin-top: 20px;">
            <label for="reset-email">üìß Email Amministratore</label>
            <input type="email" id="reset-email" class="form-group input" value="${email}" required>
        </div>
    `;
    footer.innerHTML = `
        <button class="btn btn-danger" onclick="closeModal('resetPasswordModal')">‚ùå Annulla</button>
        <button class="btn" id="btn-send-reset-link">üìß Invia Link</button>
    `;
    modal.style.display = 'block';

    document.getElementById('btn-send-reset-link').onclick = async () => {
        const resetEmail = document.getElementById('reset-email').value;
        if (!resetEmail) {
            showBanner('‚ùå Inserisci un indirizzo email', 'error');
            return;
        }
        
        const btn = document.getElementById('btn-send-reset-link');
        btn.textContent = '‚è≥ Invio...';
        btn.disabled = true;
        
        try {
            const result = await makeRequest('requestPasswordReset', { email: resetEmail });
            showBanner('‚úÖ Link di reset inviato! Controlla la tua email', 'success', 5000);
            closeModal('resetPasswordModal');
        } catch (error) {
            showBanner('‚ùå Errore: ' + error.message, 'error');
        } finally {
            btn.textContent = 'üìß Invia Link';
            btn.disabled = false;
        }
    };
}

// ‚úÖ FUNZIONE: Controlla se c'√® un token di reset nell'URL
function checkForResetToken() {
    const token = serverData.resetToken;
    if (token) {
        history.pushState(null, "", window.location.pathname);

        const modal = document.getElementById('resetPasswordModal');
        const title = document.getElementById('resetModalTitle');
        const content = document.getElementById('resetContent');
        const footer = document.getElementById('resetFooter');

        title.textContent = 'üîë Imposta Nuova Password';
        content.innerHTML = `
            <p>Inserisci la tua nuova password.</p>
            <div class="form-group" style="margin-top: 15px;">
                <label for="new-reset-password">üîë Nuova Password (almeno 6 caratteri)</label>
                <input type="password" id="new-reset-password" class="form-group input" required>
            </div>
            <div class="form-group">
                <label for="confirm-reset-password">‚úÖ Conferma Nuova Password</label>
                <input type="password" id="confirm-reset-password" class="form-group input" required>
            </div>
        `;
        footer.innerHTML = `
            <button class="btn btn-danger" onclick="closeModal('resetPasswordModal')">‚ùå Annulla</button>
            <button class="btn" id="btn-save-new-password">üíæ Salva Password</button>
        `;
        modal.style.display = 'block';

        document.getElementById('btn-save-new-password').onclick = async () => {
            const newPassword = document.getElementById('new-reset-password').value;
            const confirmPassword = document.getElementById('confirm-reset-password').value;

            if (newPassword.length < 6) {
                showBanner('‚ùå La password deve essere di almeno 6 caratteri', 'error');
                return;
            }
            if (newPassword !== confirmPassword) {
                showBanner('‚ùå Le password non coincidono', 'error');
                return;
            }

            const btn = document.getElementById('btn-save-new-password');
            btn.textContent = '‚è≥ Salvataggio...';
            btn.disabled = true;

            try {
                const result = await makeRequest('performPasswordReset', {
                    token,
                    newPassword
                });
                showBanner('‚úÖ Password aggiornata con successo!', 'success', 5000);
                closeModal('resetPasswordModal');
            } catch (error) {
                showBanner('‚ùå Errore: ' + error.message, 'error');
            } finally {
                btn.textContent = 'üíæ Salva Password';
                btn.disabled = false;
            }
        };
    }
}

function injectCheckboxCSS() {
    const checkboxCSS = `
     .checkbox-large { width: 20px !important; height: 20px !important; cursor: pointer; accent-color: #74b9ff; transform: scale(1.3); margin-right: 8px; }
     .checkbox-container { display: flex; align-items: center; gap: 10px; margin: 12px 0; padding: 12px; background: rgba(116, 185, 255, 0.08); border-radius: 8px; border: 1px solid rgba(116, 185, 255, 0.2); }
     .checkbox-label { font-weight: 600; cursor: pointer; user-select: none; font-size: 0.95rem; }
     .checkbox-container:hover { background: rgba(116, 185, 255, 0.12); border-color: rgba(116, 185, 255, 0.3); }`;
    const style = document.createElement('style');
    style.textContent = checkboxCSS;
    document.head.appendChild(style);
}

function setStatusFilter(filter) {
    currentStatusFilter = filter;
    document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
    const targetBtn = document.querySelector(`.filter-btn[data-filter="${filter}"]`);
    if (targetBtn) {
        targetBtn.classList.add('active');
    }
    updateEventiSpecialiTable();
}

async function updateEventStats() {
    try {
        const result = await makeRequest('getEventStats');
        const stats = result.data.statusCounts;
        const statElements = {
            'stat-tutti': stats.tutti,
            'stat-in_attesa': stats.in_attesa,
            'stat-approvato': stats.approvato,
            'stat-rifiutato': stats.rifiutato
        };
        Object.entries(statElements).forEach(([id, value]) => {
            const element = document.getElementById(id);
            if (element) element.textContent = value;
        });
    } catch (error) {
        console.error("Impossibile caricare le statistiche degli eventi:", error);
    }
}

function togglePasswordVisibility() {
    const passwordField = document.getElementById('loginPassword');
    const toggleBtn = document.getElementById('password-toggle');
    if (passwordField.type === 'password') {
        passwordField.type = 'text';
        toggleBtn.textContent = 'üôà';
        toggleBtn.title = 'Nascondi password';
    } else {
        passwordField.type = 'password';
        toggleBtn.textContent = 'üëÅÔ∏è';
        toggleBtn.title = 'Mostra password';
    }
}

function handlePasswordInput() {
    const passwordField = document.getElementById('loginPassword');
    const toggleBtn = document.getElementById('password-toggle');
    passwordField.type = 'text';
    toggleBtn.textContent = 'üôà';
    if (passwordTimeout) {
        clearTimeout(passwordTimeout);
    }
    passwordTimeout = setTimeout(() => {
        if (passwordField.type === 'text') {
            passwordField.type = 'password';
            toggleBtn.textContent = 'üëÅÔ∏è';
            toggleBtn.title = 'Mostra password';
        }
    }, 2000);
}

function toggleAdminCampoSelection() {
    const evento = document.getElementById("adminEvento")?.value || "";
    const emailGroup = document.getElementById("adminEmailGroup");
    const emailField = document.getElementById("adminEmail");
    const recurringGroup = document.getElementById("adminRecurringGroup");
    const confirmGroup = document.getElementById("adminConfirmGroup");
    const adminNoteGroup = document.getElementById('admin-note-group');
    const adminExclusiveDetails = document.getElementById('admin-exclusive-event-details');
    const adminPersonCount = document.getElementById('admin-person-count');
    const isSpecialEvent = evento === "compleanno" || evento === "eventi";
    if (isSpecialEvent) {
        if (emailGroup) emailGroup.style.display = "block";
        if (emailField) emailField.required = true;
        if (recurringGroup) recurringGroup.style.display = "none";
        if (confirmGroup) confirmGroup.style.display = "block";
        const ricorrenteField = document.getElementById('adminRicorrente');
        if (ricorrenteField) ricorrenteField.checked = false;
        if (adminNoteGroup) adminNoteGroup.style.display = 'none';
        if (adminExclusiveDetails) adminExclusiveDetails.style.display = 'block';
        if (adminPersonCount) adminPersonCount.required = true;
    } else {
        if (emailGroup) emailGroup.style.display = "none";
        if (emailField) {
            emailField.required = false;
            emailField.value = "";
        }
        if (recurringGroup) recurringGroup.style.display = "block";
        if (confirmGroup) {
            confirmGroup.style.display = "none";
            const confirmCheckbox = document.getElementById('adminConfermaEvento');
            if (confirmCheckbox) confirmCheckbox.checked = false;
        }
        if (adminNoteGroup) adminNoteGroup.style.display = 'block';
        if (adminExclusiveDetails) adminExclusiveDetails.style.display = 'none';
        if (adminPersonCount) adminPersonCount.required = false;
    }
}

function getBookingsWithCache(force = false) {
    const now = new Date().getTime();
    if (!force && cache.bookings && cache.timestamp && (now - cache.timestamp < cache.duration)) {
        console.log("CACHE HIT: Using cached bookings.");
        return Promise.resolve({
            data: {
                bookings: cache.bookings
            }
        });
    }

    console.log("CACHE MISS: Fetching fresh bookings from server.");
    return makeRequest('getBookings').then(result => {
        cache.bookings = (result.data.bookings || []).map(b => ({ ...b,
            data: b.data ? b.data.split('T')[0] : ''
        }));
        cache.timestamp = new Date().getTime();
        console.log("Cache updated successfully.");
        return {
            data: {
                bookings: cache.bookings
            }
        };
    }).catch(error => {
        if (cache.bookings) {

            console.warn("Server request failed. Using stale cache as fallback.");
            showBanner('‚ö†Ô∏è Errore di rete. Visualizzando dati non aggiornati.', 'error', 5000);
            return Promise.resolve({
                data: {
                    bookings: cache.bookings
                }
            });
        }
        return Promise.reject(error);
    });
}
async function loadInitialData(force = false) {
    try {
        const result = await getBookingsWithCache(force);
        bookings = result.data.bookings;

        const calendarResult = await makeRequest('getBookingsForCalendar');
        if (calendarResult.status === 'ok') {
            calendarBookings = calendarResult.data.bookings;
        }

                await updateAllPanels();
        if (isAdminLoggedIn) {
            renderMonthlyCalendar();
            // Aggiorna visibilit√† admin
            updateAdminManagementVisibility();
        }

        // ‚úÖ AGGIUNTA: Aggiorna visibilit√† campo email per admin
        updateEmailFieldVisibility();

    } catch (error) {
        console.error("Failed to load initial data:", error);
        await updateAllPanels();
    }
}

async function refreshData(event) {
    const btn = event.target;
    btn.classList.add('loading');
    btn.disabled = true;
    try {
        await loadInitialData(true);
        if (document.getElementById('admin-calendar').style.display === 'block') {
        renderMonthlyCalendar();
    }
        showBanner('‚úÖ Dati aggiornati', 'success');
    } catch (error) {} finally {
        btn.classList.remove('loading');
        btn.disabled = false;
    }
}

async function testArchive(event) {
    const btn = event.target;
    btn.classList.add('loading');
    btn.disabled = true;
    try {
        const result = await makeRequest('archiveOldBookings');
        if (result.status === 'ok') {
            showBanner(`‚úÖ Test archiviazione completato: ${result.data.archivedCount} eventi archiviati`, 'success');
            await loadInitialData(true);
        } else {
            showBanner(`‚ùå Errore: ${result.message}`, 'error');
        }
    } catch (error) {
        showBanner('‚ùå Errore durante il test', 'error');
    } finally {
        btn.classList.remove('loading');
        btn.disabled = false;
    }
}

async function manualArchive(event) {
    const btn = event.target;
    btn.classList.add('loading');
    btn.disabled = true;
    try {
        const result = await makeRequest('manualArchive');
        if (result.status === 'ok') {
            showBanner(`‚úÖ Archiviazione manuale completata: ${result.data.archivedCount} eventi archiviati`, 'success');
            await loadInitialData(true);
        } else {
            showBanner(`‚ùå Errore: ${result.message}`, 'error');
        }
    } catch (error) {
        showBanner('‚ùå Errore durante l\'archiviazione manuale', 'error');
    } finally {
        btn.classList.remove('loading');
        btn.disabled = false;
    }
}

async function refreshCalendarData() {
    try {
        const calendarResult = await makeRequest('getBookingsForCalendar');
        if (calendarResult.status === 'ok') {
            calendarBookings = calendarResult.data.bookings;
            console.log('üìÖ Dati calendario aggiornati:', calendarBookings.length, 'eventi');
        }
    } catch (error) {
        console.error('‚ùå Errore aggiornamento calendario:', error);
    }
}

function makeRequest(action, data = {}) {
    return new Promise((resolve, reject) => {
        // Timeout pi√π breve
        const timeout = setTimeout(() => {
            updateStatus('Timeout - Riprovo...', false);
            reject(new Error('Timeout richiesta'));
        }, 20000);
        
        try {
            google.script.run
                .withSuccessHandler(response => {
                    clearTimeout(timeout);
                    
                    if (!response || response.status === 'error') {
                        const errorMessage = response ? response.message : "Errore sconosciuto";
                        updateStatus('Offline', false);
                        showBanner(`‚ùå Errore: ${errorMessage}`, 'error');
                        reject(new Error(errorMessage));
                    } else {
                        updateStatus('Connesso', true);
                        resolve(response);
                    }
                })
                .withFailureHandler(error => {
                    clearTimeout(timeout);
                    updateStatus('Offline', false);
                    
                    // Ignora errori message port
                    if (error.message && error.message.includes('message port')) {
                        console.warn('‚ö†Ô∏è Message port error ignorato');
                        // Riprova una volta
                        setTimeout(() => {
                            google.script.run
                                .withSuccessHandler(resolve)
                                .withFailureHandler(reject)
                                .serverRequest(action, data);
                        }, 1000);
                    } else {
                        showBanner(`‚ùå Errore: ${error.message}`, 'error');
                        reject(error);
                    }
                })
                .serverRequest(action, data);
                
        } catch (error) {
            clearTimeout(timeout);
            reject(error);
        }
    });
}

async function updateAllPanels() {
    if (isAdminLoggedIn) {
        await updateAllAdminPanels();
    }
}

function selectEvent(eventType) {
    if (selectedEvent && selectedEvent !== eventType) {
        console.log(`üîÑ Cambio da ${selectedEvent} a ${eventType} - reset parziale`);
        resetFormKeepingData();
    } else {
        console.log(`üÜï Prima selezione evento: ${eventType}`);
        resetForm();
    }

    selectedEvent = eventType;
    
    // NUOVO: Tutti gli eventi usano il calendario
    document.getElementById('main-section-title').textContent = 'SCEGLI LA DATA';
    document.getElementById('bookingForm').style.display = 'none';
    document.getElementById('publicCalendar').style.display = 'block';
    document.getElementById('btn-back').style.display = 'block';
    
    // Aggiorna titolo calendario
    document.getElementById('selectedEventName').textContent = getEventName(eventType);
    
    // Imposta campo appropriato
    if (eventType === 'compleanno' || eventType === 'eventi') {
        currentBooking.campo = 'entrambi'; // Eventi speciali occupano tutto
    } else {
        currentBooking.campo = eventType; // Eventi normali
    }
    
    // ‚úÖ FIX CRITICO: Reset forzato della data PRIMA di inizializzare
    console.log(`üîÑ Reset data calendario per cambio evento: ${eventType}`);
    const now = new Date();
    publicCalendarDate = new Date(now.getFullYear(), now.getMonth(), 1);
    
    // Reset stati calendario
    calendarInitialized = false;
    isCalendarUpdating = false;
    
    console.log(`üìÖ Data calendario resetata a: ${publicCalendarDate.toISOString()}`);
    
    // Inizializza calendario pubblico
    initializePublicCalendar();
    
    console.log(`‚úÖ Evento selezionato: ${eventType} (calendario reinizializzato)`);
}


function resetForm() {
    document.getElementById('bookingForm').style.display = 'none';
    document.getElementById('btn-back').style.display = 'none';
    document.getElementById('campoSelection').style.display = 'none';
    document.getElementById('note-group').style.display = 'block';
    document.getElementById('exclusive-event-details').style.display = 'none';
    document.getElementById('person-count').required = false;
    const form = document.getElementById('bookingForm');
    form.reset();

    selectedEvent = '';
    currentBooking = {};

    document.getElementById('nome').value = '';
    document.getElementById('email').value = '';
    document.getElementById('telefono').value = '';
    document.getElementById('data').value = '';
    document.getElementById('ora').value = '';
    document.getElementById('note').value = '';
    document.getElementById('person-count').value = '';
    document.getElementById('other-requests').value = '';
    const musicRadios = document.querySelectorAll('input[name="music-option"]');
    musicRadios.forEach(radio => radio.checked = false);
    document.getElementById('music-no').checked = true;

    const tablesRadios = document.querySelectorAll('input[name="tables-option"]');
    tablesRadios.forEach(radio => radio.checked = false);
    document.getElementById('tables-no').checked = true;

    // ‚úÖ AGGIUNTA: Gestione campo email per admin
    updateEmailFieldVisibility();

    console.log('‚úÖ Form completamente resettato');
}

function resetFormKeepingData() {
    selectedEvent = '';
    currentBooking = {};

    document.getElementById('campoSelection').style.display = 'none';
    document.getElementById('note-group').style.display = 'block';
    document.getElementById('exclusive-event-details').style.display = 'none';
    document.getElementById('person-count').required = false;

    document.getElementById('person-count').value = '';
    document.getElementById('other-requests').value = '';
    const musicRadios = document.querySelectorAll('input[name="music-option"]');
    musicRadios.forEach(radio => radio.checked = false);
    document.getElementById('music-no').checked = true;
    const tablesRadios = document.querySelectorAll('input[name="tables-option"]');
    tablesRadios.forEach(radio => radio.checked = false);
    document.getElementById('tables-no').checked = true;

    // ‚úÖ AGGIUNTA: Gestione campo email per admin
    updateEmailFieldVisibility();

    console.log('‚úÖ Form evento resettato, dati personali mantenuti');
}

// ‚úÖ NUOVA FUNZIONE: Gestisce la visibilit√† del campo email per admin
function updateEmailFieldVisibility() {
    const emailField = document.getElementById('email');
    const emailLabel = emailField ? emailField.previousElementSibling : null;
    
    if (isAdminLoggedIn && currentAdminEmail) {
        // Admin loggato: nascondi campo email e mostra info
        if (emailField) {
            emailField.style.display = 'none';
            emailField.required = false;
            emailField.value = currentAdminEmail; // Imposta la mail dell'admin
        }
        if (emailLabel) {
            emailLabel.innerHTML = `üìß Email: <em>(email amministratore: ${currentAdminEmail})</em>`;
            emailLabel.style.color = '#28a745';
        }
    } else {
        // Utente normale: mostra campo email
        if (emailField) {
            emailField.style.display = 'block';
            emailField.required = true;
        }
        if (emailLabel) {
            emailLabel.innerHTML = 'üìß Email: <em>(campo obbligatorio)</em>';
            emailLabel.style.color = '';
        }
    }
}

// ‚úÖ NUOVA FUNZIONE: Gestisce la visibilit√† del campo email nel modal per admin
function updateModalEmailFieldVisibility() {
    const emailField = document.getElementById('modalEmail');
    const emailLabel = document.getElementById('modalEmailLabel');
    
    if (isAdminLoggedIn && currentAdminEmail) {
        // Admin loggato: nascondi campo email e mostra info
        if (emailField) {
            emailField.style.display = 'none';
            emailField.required = false;
            emailField.value = currentAdminEmail; // Imposta la mail dell'admin
        }
        if (emailLabel) {
            emailLabel.innerHTML = `üìß Email: <em>(email amministratore: ${currentAdminEmail})</em>`;
            emailLabel.style.color = '#28a745';
        }
    } else {
        // Utente normale: mostra campo email
        if (emailField) {
            emailField.style.display = 'block';
            emailField.required = true;
        }
        if (emailLabel) {
            emailLabel.innerHTML = 'üìß Email: <em>(campo obbligatorio)</em>';
            emailLabel.style.color = '';
        }
    }
}

function submitBooking() {
    if (!document.getElementById('bookingForm').checkValidity() || !selectedEvent) {
        showBanner('‚ùå Compila tutti i campi obbligatori.', 'error');
        return;
    }

    let finalNote = '';
    const isExclusive = selectedEvent === 'compleanno' ||
        selectedEvent === 'eventi';

    if (isExclusive) {
        const personCount = document.getElementById('person-count').value;
        const musicOption = document.querySelector('input[name="music-option"]:checked').value;
        const tablesOption = document.querySelector('input[name="tables-option"]:checked').value;
        const otherRequests = document.getElementById('other-requests').value.trim();
        finalNote = `Dettagli Evento:\n- Numero Persone: ${personCount}\n- Impianto Musicale: ${musicOption}\n- Tavoli e Sedie: ${tablesOption}`;
        if (otherRequests) {
            finalNote += `\n- Altre Richieste: ${otherRequests}`;
        }
    } else {
        finalNote = document.getElementById('note').value.trim();
    }

    let campoValue = (selectedEvent === 'calcetto' || selectedEvent === 'pallavolo') ? selectedEvent : 'entrambi';
    
    // ‚úÖ GESTIONE EMAIL ADMIN: Se l'admin √® loggato, usa la sua email
    let emailValue;
    if (isAdminLoggedIn && currentAdminEmail) {
        emailValue = currentAdminEmail;
    } else {
        emailValue = document.getElementById('email').value.trim();
    }
    
    currentBooking = {
        id: `ANSPI-${generateShortId()}`,
        nome: document.getElementById('nome').value.trim(),
        email: emailValue,
        telefono: document.getElementById('telefono').value.trim(),
        evento: selectedEvent,
        campo: campoValue,
        data: document.getElementById('data').value,
        ora: document.getElementById('ora').value,
        note: finalNote,
        ricorrente: false,
        // ‚úÖ Aggiungi adminActionBy se l'admin √® loggato
        adminActionBy: isAdminLoggedIn && currentAdminEmail ? currentAdminEmail : undefined
    };
    showConfirmModal(currentBooking, () => finalConfirmBooking('user'));
}

function showConfirmModal(booking, onConfirm) {
    document.getElementById('confirmModalTitle').textContent = 'üìã Riepilogo Prenotazione';
    document.getElementById('confirmContent').innerHTML = `
        <div class="confirm-modal-body">
            <p><strong>Codice:</strong> ${booking.id}</p>
            <p><strong>Nome:</strong> ${booking.nome}</p>
            <p><strong>Evento:</strong> ${getEventName(booking.evento)}</p>
            <p><strong>Campo:</strong> ${getCampoName(booking.campo)}</p>
            <p><strong>Data:</strong> ${formatDate(booking.data)} ore ${booking.ora}</p>

          <p style="margin-top: 10px;">Sei sicuro di voler confermare?</p>
        </div>
    `;
    const confirmBtn = document.getElementById('btn-confirm-final-booking');
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.innerHTML = '‚úÖ Conferma';
    newConfirmBtn.onclick = onConfirm;
    document.getElementById('confirmModal').style.display = 'block';
}

function showGenericConfirmModal(title, question, onConfirm) {
    document.getElementById('confirmModalTitle').textContent = title;
    document.getElementById('confirmContent').innerHTML = `<div class="confirm-modal-body"><p>${question}</p></div>`;
    const confirmBtn = document.getElementById('btn-confirm-final-booking');
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.innerHTML = '‚úÖ Conferma';
    newConfirmBtn.onclick = () => {
        onConfirm();
        closeModal('confirmModal');
    };
    document.getElementById('confirmModal').style.display = 'block';
}

function showPromptModal(title, question, onConfirm) {
    document.getElementById('confirmModalTitle').textContent = title;
    document.getElementById('confirmContent').innerHTML = `<div class="confirm-modal-body" style="text-align: left;">
         <p>${question}</p>
         <div class="form-group" style="margin-top: 15px;">
             <label for="promptInput">Motivazione (opzionale):</label>
             <textarea id="promptInput" rows="3" class="form-group textarea" style="width: 100%; padding: 10px; font-size: 1rem;" placeholder="Inserisci qui la motivazione del rifiuto..."></textarea>
         </div>
     </div>`;
    const confirmBtn = document.getElementById('btn-confirm-final-booking');
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.innerHTML = '‚ùå Rifiuta Evento';
    newConfirmBtn.onclick = () => {
        const reason = document.getElementById('promptInput').value.trim();
        onConfirm(reason);
        closeModal('confirmModal');
    };

    document.getElementById('confirmModal').style.display = 'block';
}
async function finalConfirmBooking(formContext = 'user') {
    const btn = document.getElementById('btn-confirm-final-booking');
    btn.classList.add('loading');
    btn.disabled = true;
    closeModal('confirmModal');

    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'booking-loading';
    loadingDiv.innerHTML = `
        <div style="text-align: center; background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);
                    color: white; padding: 20px; margin-top: 20px; border-radius: 12px;
                    box-shadow: 0 4px 20px rgba(116, 185, 255, 0.3);">
            <div style="font-size: 2em; margin-bottom: 10px;">‚ö°</div>


          <h3 style="margin: 0; font-size: 1.2em;">Creazione prenotazione in corso...</h3>
            <p style="margin: 10px 0 0; opacity: 0.9; font-size: 0.9em;">
                Controllo disponibilit√† e invio conferme
            </p>
            <div style="margin-top: 15px;">
                <div
style="display: inline-block; width: 40px; height:
 4px; background: rgba(255,255,255,0.3); border-radius: 2px; overflow: hidden;">
                    <div style="width: 100%; height: 100%; background: #fdcb6e; animation: loadingBar 2s ease-in-out infinite;"></div>
                </div>
            </div>
        </div>
        <style>
            @keyframes
loadingBar {

           0% { transform: translateX(-100%);
 }
                100% { transform: translateX(100%);
 }
            }
        </style>
    `;
    const bookingSection = document.getElementById('booking-section');
    bookingSection.appendChild(loadingDiv);

    try {
        console.log('‚ö° Invio veloce prenotazione:', currentBooking);
        const timeoutPromise = new Promise((_, reject) =>
            setTimeout(() => reject(new Error('Timeout: Il server sta impiegando troppo tempo')), 15000)
        );
        const bookingPromise = makeRequest('createBooking', currentBooking);

        const result = await Promise.race([bookingPromise, timeoutPromise]);
        console.log('‚ö° Risposta veloce ricevuta:', result);

        if (loadingDiv.parentNode) loadingDiv.remove();
        if (result.status === 'exclusive_conflict') {
            console.log('üö´ Conflitto esclusivo rilevato');
            showExclusiveConflictModal(result);
        } else if (result.status === 'conflict_suggestions') {
            console.log('‚ö†Ô∏è Conflitto con suggerimenti rilevato');
            showConflictModal(result, formContext);
        } else if (result.status === 'facility_closed_error') {
            console.log('üö™ Struttura chiusa rilevato');
            showFacilityClosedModal(result);
        } else if (result.status === 'error') {
            console.log('‚ùå Errore nella creazione');
            showBanner(`‚ùå Errore: ${result.message}`, 'error');
            const btn = document.getElementById('btn-confirm-final-booking');
            if (btn) {
                btn.classList.remove('loading');
                btn.disabled = false;
            }
        } else if (result.status === 'ok') {
            console.log('‚úÖ Prenotazione creata velocemente');
            loadInitialData(true).catch(e => console.warn('Cache update failed:', e));
            const bookingSection = document.getElementById('booking-section');
            const oldConfirmation = bookingSection.querySelector('.confirmation-message');
            if (oldConfirmation) {
                oldConfirmation.remove();
            }

            const confirmationDiv = document.createElement('div');
            confirmationDiv.className = 'confirmation-message';
            confirmationDiv.innerHTML = `
    <div style="text-align: center; background: linear-gradient(135deg, #00b894 0%, #55efc4 100%);
                color: white; padding: 30px; margin-top: 20px; border-radius: 20px;
                box-shadow: 0 12px 40px rgba(0, 184, 148, 0.4);
                animation: confirmationPulse 2s ease-in-out;">


         <div style="position: relative; display: inline-block; margin-bottom: 20px;">
            <img src="https://www.gifanimate.com/data/media/1103/congratulazione-e-complimento-immagine-animata-0058.gif"
                 alt="Congratulazioni"
                 style="width: 180px; height: 180px; border-radius: 20px;
                        box-shadow: 0 8px 30px rgba(255,255,255,0.4);


                       border: 4px solid rgba(255,255,255,0.3);">
        </div>

        <h1 style="margin: 20px 0 15px; font-size: 2.2em; text-shadow: 0 3px 6px rgba(0,0,0,0.3);
                   font-weight: 800; letter-spacing: 1px;">

           üéâ CONGRATULAZIONI!
 üéâ
        </h1>

        <h2 style="margin: 10px 0 25px; font-size: 1.4em; text-shadow: 0 2px 4px rgba(0,0,0,0.2);
                   font-weight: 600; opacity: 0.95;">
            PRENOTAZIONE CONFERMATA CON SUCCESSO!
 </h2>

        <div style="background: rgba(255,255,255,0.25); padding: 25px; border-radius: 16px;
                    margin: 25px 0; border: 3px solid rgba(255,255,255,0.4);
                    box-shadow: 0 4px 20px rgba(0,0,0,0.1);">
            <p style="margin: 0 0 15px; font-size: 1.3em; font-weight: bold;">


                 üîê Il tuo codice prenotazione √®:
            </p>
            <p style="font-family: 'Courier New', monospace; font-size: 2.2em;
                      font-weight: 900; margin: 15px 0; letter-spacing: 3px;

                   text-shadow: 0 3px 6px rgba(0,0,0,0.4);
 color: #fdcb6e;
                      background: rgba(0,0,0,0.2); padding: 15px; border-radius: 10px;">
                ${currentBooking.id}
            </p>
            <p style="margin: 15px 0 0; font-size: 1em; opacity: 0.9; font-weight: 500;">

               üìß Riceverai una email di conferma
 con tutti i dettagli
            </p>
        </div>

        <div style="margin-top: 25px;
 padding: 20px; background: rgba(255,255,255,0.15);
                    border-radius: 12px; border: 2px solid rgba(255,255,255,0.2);">
            <p style="margin: 8px 0;
 font-size: 1.2em; font-weight: 600;">
                ‚úÖ <strong>Campo prenotato con successo!</strong>
            </p>
            <p style="margin: 8px 0;
 font-size: 1em; opacity: 0.9;">
                üíæ Conserva il codice per eventuali modifiche o cancellazioni
            </p>
            <p style="margin: 8px 0;
 font-size: 1em; opacity: 0.9;">
                üì± Salva questa pagina nei preferiti del browser
            </p>
        </div>
    </div>

    <style>
        @keyframes confirmationPulse {
            0% { transform: scale(0.85); opacity: 0; }
            50% {

 transform: scale(1.02); }
            100% { transform: scale(1); opacity: 1; }
        }

        .confirmation-message img {
            animation: celebrateGift 4s ease-in-out infinite;
        }

        @keyframes celebrateGift {


 0%, 100% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(-3deg) scale(1.05); }
            50% { transform: rotate(0deg) scale(1.1); }
            75% { transform: rotate(3deg) scale(1.05); }
        }

        .confirmation-message h1 {
            animation: titleGlow 3s
 ease-in-out infinite
 alternate;
        }

        @keyframes titleGlow {
            0% { text-shadow: 0 3px 6px rgba(0,0,0,0.3); }
            100% { text-shadow: 0 3px 6px rgba(0,0,0,0.3), 0 0 20px rgba(255,255,255,0.5);
 }
        }
    </style>
`;
            bookingSection.appendChild(confirmationDiv);
            setTimeout(() => {
                if (confirmationDiv.parentNode) confirmationDiv.remove();
            }, 15000);
            resetForm();
        } else {
            console.log('‚ö†Ô∏è Stato non gestito:', result.status);
            showBanner(`‚ö†Ô∏è Risposta inattesa dal server: ${result.status}`, 'error');
        }

    } catch (error) {
        console.error("‚ùå Errore veloce in finalConfirmBooking:", error);
        if (loadingDiv.parentNode) loadingDiv.remove();
        if (error.message.includes('Timeout')) {
            showBanner('‚è±Ô∏è Il server sta impiegando troppo tempo. Riprova tra qualche secondo.', 'error', 8000);
        } else {
            showBanner('‚ùå Errore di comunicazione con il server', 'error');
        }
    } finally {
        btn.classList.remove('loading');
        btn.disabled = false;
    }
}

function showExclusiveConflictModal(response) {
    const modal = document.getElementById('conflictModal');
    const content = document.getElementById('conflictContent');
    content.innerHTML = `<div style="text-align: center; padding: 20px;"><div style="font-size: 3rem; margin-bottom: 16px;">üö´</div><h3 style="color: #e74c3c; margin-bottom: 16px;">Conflitto con Evento Esclusivo</h3><p style="line-height: 1.6; margin-bottom: 20px;">${response.message}</p><div style="background: #f8f9fa; padding: 16px; border-radius: 8px; margin: 20px 0;"><strong>üí° Cosa puoi fare:</strong><br>‚Ä¢ Scegli una data diversa<br>‚Ä¢ Contatta l'amministratore<br>‚Ä¢ Verifica il calendario per slot liberi</div><button class="btn btn-danger" onclick="closeModal('conflictModal')">‚ùå Chiudi</button></div>`;
    modal.style.display = 'block';
}

function showFacilityClosedModal(response) {
    const modal = document.getElementById('conflictModal');
    const content = document.getElementById('conflictContent');
    const formattedMessage = response.message.replace(/\n/g, '<br>');
    content.innerHTML = `<div style="text-align: center; padding: 20px;">
        <div style="font-size: 3rem; margin-bottom: 16px;">üö™</div>
        <h3 style="color: #e17055; margin-bottom: 16px;">Struttura Chiusa</h3>
        <p style="line-height: 1.6; margin-bottom: 20px;">${formattedMessage}</p>
        <div style="background: #f8f9fa; padding: 16px; border-radius: 8px; margin: 20px 0;">
            <strong>üí° Cosa puoi fare:</strong><br>
            ‚Ä¢ Scegliere una data o un orario diverso.<br>

           ‚Ä¢ Contattare l'amministratore per necessit√† particolari.
     </div>
        <button class="btn" style="background: var(--primary-soft);" onclick="closeModal('conflictModal'); resetForm();">‚úÖ Ho capito</button>
    </div>`;
    modal.style.display = 'block';
}

function showConflictModal(response, formContext = 'user') {
    const modal = document.getElementById('conflictModal');
    const content = document.getElementById('conflictContent');
    const closeBtn = document.getElementById('close-conflict-modal-btn');
    let conflictHtml = `<p style="line-height: 1.6; color: var(--text-light);">L'orario scelto √® gi√† occupato da una prenotazione per <strong>${getEventName(response.conflictDetails.evento)}</strong> delle ore <strong>${response.conflictDetails.ora}</strong>.</p>`;
    const hasSuggestions = response.suggestions.before || response.suggestions.after;
    if (hasSuggestions) {
        conflictHtml += `<p style="margin-top: 20px; font-weight: 600; color: var(--text-warm);">Potresti provare uno di questi orari alternativi:</p>`;
    } else {
        conflictHtml += `<p style="margin-top: 20px; font-weight: 600; color: var(--text-warm);">Non sono stati trovati slot alternativi disponibili nelle immediate vicinanze.</p>`;
    }
    conflictHtml += `<div style="margin-top: 15px; display: flex; flex-direction: column; gap: 10px;">`;
    if (response.suggestions.before) {
        conflictHtml += `<button class="btn suggestion-btn" data-time="${response.suggestions.before}">üïí Prova alle ${response.suggestions.before} (prima)</button>`;
    }
    if (response.suggestions.after) {
        conflictHtml += `<button class="btn suggestion-btn" data-time="${response.suggestions.after}">üïí Prova alle ${response.suggestions.after} (dopo)</button>`;
    }
    conflictHtml += `</div>`;
    conflictHtml += `<div style="margin-top: 24px; border-top: 1px solid #eee; padding-top: 16px; display: flex; justify-content: flex-end;">`;
    conflictHtml += `<button id="close-suggestion-modal" class="btn btn-danger">Chiudi</button>`;
    conflictHtml += `</div>`;
    content.innerHTML = conflictHtml;
    modal.style.display = 'block';
    const closeModalFunc = () => modal.style.display = 'none';
    closeBtn.onclick = closeModalFunc;
    document.getElementById('close-suggestion-modal').onclick = () => {
        closeModalFunc();
        resetForm();
    };
    document.querySelectorAll('.suggestion-btn').forEach(button => {
        button.onclick = () => {
            const newTime = button.getAttribute('data-time');
            const oraInputId = formContext === 'admin' ? 'adminOra' : 'ora';
            document.getElementById(oraInputId).value = newTime;
            currentBooking.ora = newTime;

            closeModalFunc();
            showBanner(`‚úÖ Orario aggiornato alle ${newTime}. Controlla e conferma di nuovo.`, 'success', 5000);
            if (formContext === 'admin') {
                submitAdminBooking(null, true);
            } else {

                showConfirmModal(currentBooking, () => finalConfirmBooking('user'));
            }
        };
    });
    window.onclick = (event) => {
        if (event.target == modal) {
            closeModalFunc();
        }
    };
}

async function cancelBooking() {
    const code = document.getElementById('cancelCode').value.trim();
    if (!code) {
        showBanner('‚ùå Inserisci il codice', 'error');
        return;
    }
    showGenericConfirmModal('Conferma Cancellazione', `Sei sicuro di voler cancellare la prenotazione ${code}?`, async () => {
        try {
            await makeRequest('cancelBooking', {
                bookingId: code
            });
            document.getElementById('cancelCode').value = '';
            showBanner('‚úÖ Prenotazione cancellata', 'success');

            await loadInitialData(true);
        } catch (error) {}
    });
}

function promptForNewPassword(email) {
    const modal = document.getElementById('confirmModal');
    document.getElementById('confirmModalTitle').textContent = 'üîë Crea la tua Password';
    document.getElementById('confirmContent').innerHTML = `<div class="confirm-modal-body" style="text-align: left;">
         <p>Benvenuto, ${email}! √à il tuo primo accesso. Crea una password per il tuo account.</p>
         <div class="form-group" style="margin-top: 15px;">
             <label for="new-password">Nuova Password:</label>
             <input type="password" id="new-password" class="form-group input" style="width: 100%; padding: 10px; font-size: 1rem;">
         </div>
         <div class="form-group">
             <label
 for="confirm-password">Conferma Password:</label>
             <input type="password" id="confirm-password" class="form-group input" style="width: 100%; padding: 10px; font-size: 1rem;">
         </div>
     </div>`;
    const confirmBtn = document.getElementById('btn-confirm-final-booking');
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.innerHTML = 'Salva Password';
    newConfirmBtn.onclick = async () => {
        const newPassword = document.getElementById('new-password').value;
        const confirmPassword = document.getElementById('confirm-password').value;

        if (!newPassword || newPassword.length < 6) {
            showBanner('‚ùå La password deve essere di almeno 6 caratteri.', 'error');
            return;
        }
        if (newPassword !== confirmPassword) {
            showBanner('‚ùå Le password non coincidono.', 'error');
            return;
        }

        newConfirmBtn.classList.add('loading');
        newConfirmBtn.disabled = true;
        try {
            await makeRequest('createAdminPassword', {
                email,
                password: newPassword
            });
            showBanner('‚úÖ Password creata con successo! Ora puoi accedere.', 'success');
            closeModal('confirmModal');
            document.getElementById('loginPassword').value = newPassword;
        } catch (error) {
            showBanner(`‚ùå Errore nella creazione della password: ${error.message}`, 'error');
        } finally {
            newConfirmBtn.classList.remove('loading');
            newConfirmBtn.disabled = false;
        }
    };

    modal.style.display = 'block';
}
async function adminLogin(event) {
    const email = document.getElementById('loginEmail').value.trim().toLowerCase();
    const password = document.getElementById('loginPassword').value;
    if (!email) {
        showBanner('‚ùå Inserisci la tua email da amministratore.', 'error');
        return;
    }

    const btn = event.target;
    btn.classList.add('loading');
    btn.disabled = true;
    try {
        const result = await makeRequest('adminLogin', {
            email,
            password
        });
        if (result.data.action === 'CREATE_PASSWORD') {
            closeModal('confirmModal');
            promptForNewPassword(email);
        } else if (result.data.action === 'LOGIN_SUCCESS') {
            isAdminLoggedIn = true;
            currentAdminEmail = email;
            document.querySelectorAll('.booking-section, .cancel-section, .admin-login, .info-folder').forEach(el => el.style.display = 'none');
            document.getElementById('adminPanel').style.display = 'block';

            // Aggiorna visibilit√† tab gestione admin
            updateAdminManagementVisibility();
            
            // ‚úÖ AGGIUNTA: Aggiorna visibilit√† campo email per admin
            updateEmailFieldVisibility();

            await loadInitialData(true);
        }
    } catch (error) {} finally {
        btn.classList.remove('loading');
        btn.disabled = false;
    }
}

function exitAdminPanel() {
    isAdminLoggedIn = false;
    currentAdminEmail = '';
    document.querySelectorAll('.booking-section, .cancel-section, .admin-login, .info-folder').forEach(el => el.style.display = 'block');
    document.getElementById('adminPanel').style.display = 'none';
    document.getElementById('loginEmail').value = '';
    document.getElementById('loginPassword').value = '';
    
    // ‚úÖ AGGIUNTA: Ripristina visibilit√† campo email per utenti normali
    updateEmailFieldVisibility();
}

async function showAdminTab(tabName) {
    // Aggiorna visibilit√† admin all'inizio
    if (isAdminLoggedIn) {
        updateAdminManagementVisibility();
    }
    
    document.querySelectorAll('.admin-tab').forEach(tab => tab.classList.remove('active'));
    document.querySelectorAll('.admin-content').forEach(content => content.style.display = 'none');
    const tabBtn = document.querySelector(`.admin-tab[data-tab="${tabName}"]`);
    if (tabBtn) tabBtn.classList.add('active');
    const content = document.getElementById(`admin-${tabName}`);
    if (content) content.style.display = 'block';
    if (tabName === 'calendar') {
        await refreshCalendarData();
        renderMonthlyCalendar();
    }
    else if (tabName === 'archive-calendar') {
        if (archivedBookings.length === 0) {
            try {
                const result = await makeRequest('getArchivedBookings');
                if (result.status === 'ok') {
                    archivedBookings = result.data.bookings;
                }
            } catch (error) {
                console.error("Impossibile caricare l'archivio:", error);
                showBanner("‚ùå Errore nel caricamento dell'archivio.", "error");
            }
        }
        renderArchivedMonthlyCalendar();
    }

    if (tabName === 'bookings') updateBookingsTable();
    if (tabName === 'eventi-speciali') updateEventiSpecialiTable();
    if (tabName === 'gestione-campo') {
        // No extra action
    }
    if (tabName === 'gestione-admin') {
        loadAdminsList();
    }
}

async function updateAllAdminPanels() {
    updateStats();
    updateBookingsTable();
    updateEventiSpecialiTable();

    const calendarTab = document.querySelector('.admin-tab[data-tab="calendar"]');
    if (calendarTab && calendarTab.classList.contains('active')) {
        await refreshCalendarData();
    }

    renderMonthlyCalendar();
}

function updateStats() {
    const todayStr = new Date().toISOString().split("T")[0];
    const bookingsData = calendarBookings.length > 0 ? calendarBookings : bookings;
    document.getElementById("totalBookings").textContent = bookingsData.length;
    document.getElementById("todayBookings").textContent = bookingsData.filter(e => e.data.split('T')[0] === todayStr).length;
    const activeBookings = bookingsData.filter(e => new Date(e.data.split('T')[0]) >= new Date(todayStr));
    document.getElementById("activeBookings").textContent = activeBookings.length;
    const startOfWeek = new Date();
    startOfWeek.setDate(startOfWeek.getDate() - (startOfWeek.getDay() + 6) % 7);
    const weekStartStr = startOfWeek.toISOString().split('T')[0];
    document.getElementById("weekBookings").textContent = activeBookings.filter(b => b.data.split('T')[0] >= weekStartStr).length;
}

function updateBookingsTable() {
    const tbody = document.getElementById("bookingsTableBody");
    const dataSource = calendarBookings.length > 0 ?
        calendarBookings : bookings;
    const normalEvents = dataSource.filter(b => !b.id.includes('-R') && !b.id.includes('-V') && (b.evento === 'calcetto' || b.evento === 'pallavolo'));
    const sortedEvents = [...normalEvents].sort((a, b) => {
        const dateA = new Date(a.data + 'T' + a.ora);
        const dateB = new Date(b.data + 'T' + b.ora);
        return dateA - dateB;
    });
    tbody.innerHTML = sortedEvents.map(b => {
        const fieldControl = `<select data-id="${b.id}" class="admin-campo-select" style="color: black; border-radius: 5px; padding: 2px;"><option value="calcetto" ${"calcetto"===b.campo?"selected":""}>Calcetto</option><option value="pallavolo" ${"pallavolo"===b.campo?"selected":""}>Pallavolo</option></select>`;
        const recurringControl = `<input type="checkbox" data-id="${b.id}" class="admin-ricorrente-check checkbox-large" ${b.ricorrente?"checked":""}>`;

        const createdBy = b.adminactionby ?
            `<span class="admin-creator" title="${b.adminactionby}">üë®‚Äçüíº ${b.adminactionby.split('@')[0]}</span>` :
            '<span class="user-creator">üë§ Utente</span>';

        return `<tr>
                     <td>${b.id.replace('-V','')}</td>
                     <td>${b.nome}</td>
                     <td>${getEventName(b.evento)}</td>

                      <td>${fieldControl}</td>
                     <td>${formatDate(b.data)}<br>${b.ora}</td>
                     <td style="text-align:center">${recurringControl}</td>
                     <td>${createdBy}</td>
                     <td><button class="btn btn-danger admin-delete-btn"
 data-id="${b.id}" style="padding:5px 10px;font-size:12px;width:auto;min-height:auto">üóëÔ∏è</button></td>
                 </tr>`
    }).join("");
}

function updateEventiSpecialiTable() {
    const tbody = document.getElementById("eventiSpecialiTableBody");
    if (!tbody) return;
    updateEventStats();
    const dataSource = calendarBookings.length > 0 ? calendarBookings : bookings;
    let specialEvents = dataSource.filter(b => !b.id.includes('-R') && !b.id.includes('-V') && (b.evento === 'compleanno' || b.evento === 'eventi'));
    if (currentStatusFilter !== 'tutti') {
        specialEvents = specialEvents.filter(b => (b.stato || 'in_attesa') === currentStatusFilter);
    }

    const sortedSpecialEvents = [...specialEvents].sort((a, b) => {
        const dateA = new Date(a.data + 'T' + a.ora);
        const dateB = new Date(b.data + 'T' + b.ora);
        return dateA - dateB;
    });
    tbody.innerHTML = sortedSpecialEvents.map(b => {
        const statusBadge = getStatusBadge(b.stato || 'in_attesa');
        const actionButtons = getActionButtons(b.id, b.stato || 'in_attesa');
        return `<tr>
             <td>${b.id.replace('-V','')}</td>
             <td>${b.nome}</td>
             <td>${b.email}</td>

              <td>${getEventName(b.evento)}</td>
             <td>${formatDate(b.data)}<br>${b.ora}</td>
             <td style="text-align:center">${statusBadge}</td>
             <td style="text-align:center">${actionButtons}</td>
         </tr>`
    }).join("");
}

function getStatusBadge(stato) {
    const badges = {
        'in_attesa': '<span style="background: #ffc107; color: #000; padding: 4px 8px; border-radius: 12px; font-size: 12px; font-weight: bold;">‚è≥ In Attesa</span>',
        'approvato': '<span style="background: #28a745; color: #fff; padding: 4px 8px; border-radius: 12px; font-size: 12px; font-weight: bold;">‚úÖ Approvato</span>',
        'rifiutato': '<span style="background: #dc3545; color: #fff; padding: 4px 8px; border-radius: 12px; font-size: 12px; font-weight: bold;">‚ùå Rifiutato</span>'
    };
    return badges[stato] || badges['in_attesa'];
}

function getActionButtons(bookingId, stato) {
    if (stato === 'approvato') {
        return `<button class="btn btn-danger admin-delete-btn" data-id="${bookingId}" style="padding:4px 8px;font-size:11px;">üóëÔ∏è</button>`;
    } else if (stato === 'rifiutato') {
        return `<button class="btn btn-success approve-btn" data-id="${bookingId}" style="padding:4px 8px;font-size:11px;margin-right:4px;">‚úÖ</button>
                 <button class="btn btn-danger admin-delete-btn" data-id="${bookingId}" style="padding:4px 8px;font-size:11px;">üóëÔ∏è</button>`;
    } else {
        return `<button class="btn btn-success approve-btn" data-id="${bookingId}" style="padding:4px 8px;font-size:11px;margin-right:4px;">‚úÖ</button>
                 <button class="btn btn-danger reject-btn" data-id="${bookingId}" style="padding:4px 8px;font-size:11px;">‚ùå</button>`;
    }
}

async function approveEvent(bookingId) {
    showGenericConfirmModal('Conferma Approvazione', `Sei sicuro di voler approvare l'evento ${bookingId}?`, async () => {
        try {
            await makeRequest('updateEventStatus', {
                bookingId,
                newStatus: 'approvato',
                adminEmail: currentAdminEmail
            });
            showBanner('‚úÖ Evento approvato con successo', 'success');
            await loadInitialData(true);

        } catch (error) {
            showBanner('‚ùå Errore nell\'approvazione', 'error');
        }
    });
}

async function rejectEvent(bookingId) {
    showPromptModal('Conferma Rifiuto Evento', `Sei sicuro di voler rifiutare l'evento ${bookingId}?`, async (reason) => {
        try {
            await makeRequest('updateEventStatus', {
                bookingId,
                newStatus: 'rifiutato',
                reason: reason,
                adminEmail: currentAdminEmail
            });
            showBanner('‚ùå Evento rifiutato', 'error');
            await loadInitialData(true);

        } catch (error) {
            showBanner('‚ùå Errore nel rifiuto', 'error');
        }
    });
}

function getEventsForDate(dateString) {
    // Usa calendarBookings per avere una visione completa di tutti gli eventi
    const dataSource = calendarBookings.length > 0 ? calendarBookings : bookings;
    
    // Preparazione delle date di riferimento
    const today = new Date();
    const todayStart = new Date(today.getFullYear(), today.getMonth(), today.getDate());
    const currentDate = new Date(dateString.split('T')[0]); // Assicura che si confronti solo la data
    
    // 1. Filtra gli eventi singoli (non ricorrenti) che corrispondono alla data richiesta
    const singleEvents = dataSource.filter(b => {
        const isRecurring = b.ricorrente === true || b.ricorrente === 'TRUE' || b.ricorrente === 'true' || b.ricorrente === 's√¨';
        if (!b.data || isRecurring) return false; // Salta se non ha data o se √® una master ricorrente
        
        const eventDate = new Date(b.data.split('T')[0]);
        // Confronta solo la parte della data
        return eventDate.getTime() === currentDate.getTime();
    });
    
    // 2. ‚úÖ CORREZIONE: Genera ricorrenze virtuali SOLO per le prossime 2 settimane
    const recurringEvents = dataSource
        .filter(b => {
            const isRecurring = b.ricorrente === true || b.ricorrente === 'TRUE' || b.ricorrente === 'true' || b.ricorrente === 's√¨';
            return isRecurring; // Prendi solo le prenotazioni "master" ricorrenti
        })
        .filter(masterEvent => {
            const masterDate = new Date(masterEvent.data.split('T')[0]);
            
            // ‚úÖ NUOVO: Controlla se il giorno della settimana corrisponde
            const sameWeekday = currentDate.getDay() === masterDate.getDay();
            
            // ‚úÖ NUOVO: La data corrente deve essere dopo la data master
            const isAfterMaster = currentDate >= masterDate;
            
            // ‚úÖ NUOVO: LIMITE: Solo fino a 2 settimane nel futuro
            const twoWeeksFromToday = new Date(todayStart);
            twoWeeksFromToday.setDate(todayStart.getDate() + 14);
            const isWithinTwoWeeks = currentDate <= twoWeeksFromToday;
            
            // ‚úÖ NUOVO: Non mostrare ricorrenze per date passate
            const isNotPast = currentDate >= todayStart;
            
            console.log(`üîç Ricorrenza ${masterEvent.nome}:`, {
                sameWeekday,
                isAfterMaster, 
                isWithinTwoWeeks,
                isNotPast,
                masterDate: masterDate.toISOString().split('T')[0],
                currentDate: dateString,
                todayStart: todayStart.toISOString().split('T')[0]
            });
            
            return sameWeekday && isAfterMaster && isWithinTwoWeeks && isNotPast;
        })
        .map(masterEvent => {
            // Crea una copia virtuale dell'evento per la data corrente
            return {
                ...masterEvent, 
                data: dateString, 
                id: `${masterEvent.id}-V` // Aggiungi un suffisso per identificarlo come virtuale
            };
        });

    // Debug per eventi ricorrenti
    const allRecurringEvents = dataSource.filter(b => {
        const isRecurring = b.ricorrente === true || b.ricorrente === 'TRUE' || b.ricorrente === 'true' || b.ricorrente === 's√¨';
        return isRecurring;
    });
    
    console.log(`üìÖ Eventi per ${dateString}:`, {
        singoli: singleEvents.length,
        ricorrenti: recurringEvents.length,
        totale: singleEvents.length + recurringEvents.length,
        tuttiRicorrenti: allRecurringEvents.map(e => ({ nome: e.nome, ricorrente: e.ricorrente, tipo: typeof e.ricorrente }))
    });

    // 3. Unisci eventi singoli e ricorrenze virtuali
    const allEventsForDay = [...singleEvents, ...recurringEvents];

    // 4. Filtra per stato (mostra solo approvati o eventi che non necessitano approvazione)
    return allEventsForDay.filter(event => event.stato !== 'in_attesa' && event.stato !== 'rifiutato');
}


// =====================================================
// NUOVA FUNZIONE renderMonthlyCalendar() CON BADGE RICORRENTI
// Sostituisci COMPLETAMENTE la funzione esistente con questo codice
// =====================================================

function renderMonthlyCalendar() {
    const month = calendarDate.getMonth();
    const year = calendarDate.getFullYear();
    document.getElementById('monthYear').textContent = `${new Date(year, month).toLocaleString("it-IT",{month:"long",year:"numeric"})}`;
    
    const daysEl = document.getElementById('calendarDays');
    daysEl.innerHTML = "";
    
    const weekdaysEl = document.getElementById('calendarWeekdays');
    weekdaysEl.innerHTML = "";
    ["Lun", "Mar", "Mer", "Gio", "Ven", "Sab", "Dom"].forEach(day => {
        weekdaysEl.innerHTML += `<div class="calendar-day-header">${day}</div>`;
    });
    
    const firstDayOfMonth = new Date(year, month, 1);
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const startDayOfWeek = (firstDayOfMonth.getDay() + 6) % 7;
    
    // Giorni vuoti prima del primo giorno del mese
    for (let i = 0; i < startDayOfWeek; i++) {
        daysEl.innerHTML += '<div class="calendar-day other-month"></div>';
    }
    
    // Giorni del mese
    for (let i = 1; i <= daysInMonth; i++) {
        const dayEl = document.createElement('div');
        dayEl.className = 'calendar-day';
        const dateString = `${year}-${String(month + 1).padStart(2, '0')}-${String(i).padStart(2, '0')}`;
        dayEl.dataset.date = dateString;
        
        // Controlla se √® oggi
        const today = new Date();
        if (i === today.getDate() && month === today.getMonth() && year === today.getFullYear()) {
            dayEl.classList.add('today');
        }
        
        // Ottieni eventi per questo giorno
        const eventsForDay = getEventsForDate(dateString);
        
        let centerContent = '';
        let dayClasses = '';
        
        if (eventsForDay.length > 0) {
            
            if (eventsForDay.length === 1) {
                // Un solo evento: mostra dettagli con badge inline se ricorrente
                const event = eventsForDay[0];
                const eventIcon = ICONS[event.evento] || 'üìÖ';
                const isRecurring = event.ricorrente === true || event.ricorrente === 'true';
                
                // Badge ricorrente inline (se applicabile)
                const recurringBadge = isRecurring ? 
                    '<span class="recurring-badge-inline" title="Evento Ricorrente">üîÑ</span>' : '';
                
                centerContent = `
                    <div class="day-center-content single-event">
                        <div class="event-info-row">
                            <span class="day-event-time">${event.ora}</span>
                            <span class="day-event-icon">${eventIcon}</span>
                            ${recurringBadge}
                        </div>
                        <div class="day-event-type">${getShortEventName(event.evento)}</div>
                    </div>
                `;
                
                dayClasses = `has-event evento-${event.evento}`;
                if (isRecurring) dayClasses += ' is-recurring';
                
            } else {
                // Pi√π eventi: mostra conteggio con indicatore ricorrenti
                const recurringEvents = eventsForDay.filter(e => 
                    e.ricorrente === true || e.ricorrente === 'true'
                );
                const hasRecurring = recurringEvents.length > 0;
                
                centerContent = `
                    <div class="day-center-content multiple-events">
                        <div class="events-count-row">
                            <span class="day-event-count">${eventsForDay.length}</span>
                            ${hasRecurring ? '<span class="recurring-badge-inline">üîÑ</span>' : ''}
                        </div>
                        <div class="day-event-label">eventi</div>
                        ${hasRecurring ? `<div class="recurring-info">${recurringEvents.length} ricorr.</div>` : ''}
                    </div>
                `;
                
                dayClasses = 'has-multiple-events';
                if (hasRecurring) dayClasses += ' has-recurring';
            }
            
        } else {
            // Nessun evento: giorno disponibile
            centerContent = `
                <div class="day-center-content available">
                    <div class="availability-indicator">üü¢</div>
                </div>
            `;
            
            dayClasses = 'day-available';
        }
        
        // Costruisci HTML del giorno
        dayEl.innerHTML = `
            <div class="day-number">${i}</div>
            ${centerContent}
        `;
        
        // Aggiungi classi CSS
        if (dayClasses) {
            dayEl.className += ' ' + dayClasses;
        }
        
        // Mini barre colorate in basso per visualizzazione rapida
        if (eventsForDay.length > 0 && eventsForDay.length <= 3) {
            const eventsContainer = document.createElement('div');
            eventsContainer.className = 'events-container-mini';
            
            eventsForDay.slice(0, 3).forEach((event) => {
                const eventBar = document.createElement('div');
                eventBar.className = `mini-event-bar evento-${event.evento}`;
                eventBar.style.background = getEventColor(event.evento);
                eventsContainer.appendChild(eventBar);
            });
            
            dayEl.appendChild(eventsContainer);
        }
        
        // Event listener per click
        dayEl.onclick = (e) => {
            if (!e.target.closest('.monthly-event-bar')) {
                if (eventsForDay.length > 0) {
                    showDaySummaryModal(dateString, eventsForDay);
                }
            }
        };
        
        // Tooltip dettagliato
        if (eventsForDay.length > 0) {
            const tooltipText = eventsForDay.map(e => {
                const recurringSymbol = (e.ricorrente === true || e.ricorrente === 'true') ? 'üîÑ ' : '';
                return `${recurringSymbol}${e.ora} - ${getEventName(e.evento)} (${e.nome})`;
            }).join('\n');
            dayEl.title = tooltipText;
        }
        
        daysEl.appendChild(dayEl);
    }
    
    // Setup extra per admin se loggato
    if (isAdminLoggedIn) {
        setTimeout(() => {
            setupCalendarDoubleClick();
            addCalendarTooltips();
        }, 100);
    }
}

// =====================================================
// FUNZIONE HELPER PER NOMI BREVI DEGLI EVENTI
// Aggiungi questa funzione DOPO la funzione renderMonthlyCalendar()
// =====================================================

// Funzione helper per nomi brevi degli eventi
function getShortEventName(type) {
    return {
        calcetto: 'Calcetto',
        pallavolo: 'Volley',
        compleanno: 'Festa',
        eventi: 'Evento'
    }[type] || type;
}

function renderWeeklyCalendar() {
    const timeLabelsEl = document.getElementById('timeLabels');
    const daysContainerEl = document.getElementById('daysContainer');
    timeLabelsEl.innerHTML = '';
    daysContainerEl.innerHTML = '';
    for (let i = 8; i <= 22; i++) {
        timeLabelsEl.innerHTML += `<div class="time-label">${i}:00</div>`;
    }
    const startOfWeek = new Date(calendarDate);
    startOfWeek.setDate(startOfWeek.getDate() - (startOfWeek.getDay() + 6) % 7);
    const endOfWeek = new Date(startOfWeek);
    endOfWeek.setDate(startOfWeek.getDate() + 6);
    document.getElementById('weekRange').textContent = `${formatDate(startOfWeek.toISOString().split('T')[0])} - ${formatDate(endOfWeek.toISOString().split('T')[0])}`;
    for (let i = 0; i < 7; i++) {
        const day = new Date(startOfWeek);
        day.setDate(startOfWeek.getDate() + i);
        const dayStr = day.toISOString().split('T')[0];
        const dayName = day.toLocaleDateString('it-IT', {
            weekday: 'short'
        });
        let dayHtml = `<div class="day-column"><div class="day-column-header">${dayName} ${day.getDate()}</div>`;
        const eventsForDay = getEventsForDate(dayStr);
        eventsForDay.sort((a, b) => a.ora.localeCompare(b.ora)).forEach(event => {
            const [hour, minute] = event.ora.split(':').map(Number);
            const top = ((hour - 8) * 60 + minute);
            const duration = {
                calcetto: 90,
                pallavolo: 120,
                compleanno: 180,
                eventi: 180
            } [event.evento] || 60;
            const isRecurring = event.ricorrente === true || event.ricorrente === 'TRUE' || event.ricorrente === 'true' || event.ricorrente === 's√¨';
            let icon = isRecurring && !event.id.includes('-V') ? 'üîÑ' : '';

            dayHtml += `<div class="weekly-event evento-${event.evento}" style="top:${top}px; height:${duration}px; background: ${getEventColor(event.evento)};" data-event='${JSON.stringify(event)}'>
                 <div class="event-time">${event.ora} ${icon}</div>
                 <div class="event-title">${getEventName(event.evento)}</div>
                 <div class="event-name">${isRecurring && !event.id.includes('-V') ? `${event.nome} üîÑ` : event.nome}</div>
                 <div class="event-phone" style="font-size: 0.7rem; opacity: 0.9; margin-top:
 2px;">${ICONS.telefono} ${event.telefono || 'N/D'}</div>
             </div>`;
        });
        dayHtml += '</div>';
        daysContainerEl.innerHTML += dayHtml;
    }
    daysContainerEl.addEventListener('click', (e) => {
        const eventCard = e.target.closest('.weekly-event');
        if (eventCard) {
            showDetailsModal(JSON.parse(eventCard.dataset.event));
        }
    });
}

function toggleCalendarView(view) {
    document.getElementById('monthly-view').style.display = view === 'monthly' ? 'block' : 'none';
    document.getElementById('weekly-view').style.display = view === 'weekly' ?
        'block' : 'none';
    document.getElementById('btn-view-monthly').classList.toggle('active', view === 'monthly');
    document.getElementById('btn-view-weekly').classList.toggle('active', view === 'weekly');
    if (view === 'monthly') renderMonthlyCalendar();
    if (view === 'weekly') renderWeeklyCalendar();
}

function getEventColor(eventType) {
    const colors = {
        calcetto: 'var(--primary-soft)',
        pallavolo: 'var(--success-soft)',
        compleanno: 'var(--warning-soft)',
        eventi: 'var(--danger-soft)'
    };
    return colors[eventType] || 'var(--secondary-soft)';
}

function showDaySummaryModal(dateString, events) {
    document.getElementById('details-modal-title').innerHTML = `<span class="details-list-icon">${ICONS.data}</span> ${formatDate(dateString)} - ${events.length} prenotazioni`;
    const body = document.getElementById('details-modal-body');
    body.innerHTML = '';
    events.sort((a, b) => a.ora.localeCompare(b.ora)).forEach(event => {
        const card = document.createElement('div');
        card.className = `day-summary-card evento-${event.evento}`;
        card.style.background = getEventColor(event.evento);

        card.innerHTML = `
             <div><span class="details-list-icon">${ICONS.ora}</span> <strong>${event.ora}</strong> - ${getEventName(event.evento)}</div>

                                                       <div><span class="details-list-icon">${ICONS.cliente}</span> ${(event.ricorrente === true || event.ricorrente === 'TRUE' || event.ricorrente === 'true' || event.ricorrente === 's√¨') && !event.id.includes('-V') ? `${event.nome} üîÑ` : event.nome}</div>
             <div><span class="details-list-icon">${ICONS.telefono}</span> ${event.telefono || 'N/D'}</div>
             <div><span class="details-list-icon">${ICONS.campo}</span> ${getCampoName(event.campo)}</div>
         `;

        card.onclick = () => showDetailsModal(event);
        body.appendChild(card);
    });
    document.getElementById('details-modal').style.display = 'block';
}

function showDetailsModal(booking) {
    document.getElementById('details-modal-title').innerHTML = `<span class="details-list-icon">${ICONS.evento}</span> Dettagli Prenotazione`;
    const body = document.getElementById('details-modal-body');
    const creationDate = booking.timestamp ? new Date(booking.timestamp).toLocaleString('it-IT') : 'N/D';
    body.innerHTML = `<ul class="details-list"><li><span class="details-list-icon">${ICONS.codice}</span><span class="details-list-label">Codice:</span> <span class="details-list-value">${booking.id.replace('-V','')}</span></li><li><span class="details-list-icon">${ICONS.cliente}</span><span class="details-list-label">Cliente:</span> <span class="details-list-value">${booking.nome}</span></li><li><span class="details-list-icon">${ICONS.email}</span><span class="details-list-label">Email:</span> <span class="details-list-value">${booking.email}</span></li><li><span class="details-list-icon">${ICONS.telefono}</span><span class="details-list-label">Telefono:</span> <span class="details-list-value">${booking.telefono}</span></li><li><span class="details-list-icon">${ICONS.evento}</span><span class="details-list-label">Evento:</span> <span class="details-list-value">${getEventName(booking.evento)}</span></li><li><span class="details-list-icon">${ICONS.campo}</span><span class="details-list-label">Campo:</span> <span class="details-list-value">${getCampoName(booking.campo)}</span></li><li><span class="details-list-icon">${ICONS.data}</span><span class="details-list-label">Data:</span> <span class="details-list-value">${formatDate(booking.data)}</span></li><li><span class="details-list-icon">${ICONS.ora}</span><span class="details-list-label">Ora:</span> <span class="details-list-value">${booking.ora}</span></li><li><span class="details-list-icon">${ICONS.note}</span><span class="details-list-label">Note:</span> <span class="details-list-value" style="white-space: pre-wrap;">${booking.note || 'Nessuna'}</span></li><li><span class="details-list-icon">${ICONS.timestamp}</span><span class="details-list-label">Creata il:</span> <span class="details-list-value">${creationDate}</span></li></ul>`;
    document.getElementById('details-modal').style.display = 'block';
}

function getArchivedEventsForDate(dateString) {
    return archivedBookings.filter(b => {
        if (!b.data) return false;
        const eventDate = new Date(b.data.split('T')[0]);
        const currentDate = new Date(dateString.split('T')[0]);
        return eventDate.getTime() === currentDate.getTime();
    });
}

function renderArchivedMonthlyCalendar() {
    const month = archiveCalendarDate.getMonth();
    const year = archiveCalendarDate.getFullYear();
    document.getElementById('archiveMonthYear').textContent = `${new Date(year, month).toLocaleString("it-IT",{month:"long",year:"numeric"})}`;

    const daysEl = document.getElementById('archiveCalendarDays');
    daysEl.innerHTML = "";

    const weekdaysEl = document.getElementById('archiveCalendarWeekdays');
    weekdaysEl.innerHTML = "";
    ["Lun", "Mar", "Mer", "Gio", "Ven", "Sab", "Dom"].forEach(day => {
        weekdaysEl.innerHTML += `<div class="calendar-day-header">${day}</div>`;
    });

    const firstDayOfMonth = new Date(year, month, 1);
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const startDayOfWeek = (firstDayOfMonth.getDay() + 6) % 7;
    for (let i = 0; i < startDayOfWeek; i++) {
        daysEl.innerHTML += '<div class="calendar-day other-month"></div>';
    }

    for (let i = 1; i <= daysInMonth; i++) {
        const dayEl = document.createElement('div');
        dayEl.className = 'calendar-day';
        const dateString = `${year}-${String(month + 1).padStart(2, '0')}-${String(i).padStart(2, '0')}`;
        dayEl.dataset.date = dateString;
        dayEl.innerHTML = `<div class="day-number">${i}</div><div class="events-container"></div>`;
        const eventsForDay = getArchivedEventsForDate(dateString);

        if (eventsForDay.length > 0) {
            const eventsContainer = dayEl.querySelector('.events-container');
            eventsForDay.sort((a, b) => a.ora.localeCompare(b.ora)).forEach(event => {
                const eventBar = document.createElement('div');
                eventBar.className = `monthly-event-bar evento-${event.evento}`;
                eventBar.style.background = getEventColor(event.evento);
                eventBar.style.filter = 'grayscale(50%)';
                eventBar.style.opacity =
                    '0.7';

                let icon = ICONS[event.evento] || '';
                eventBar.innerHTML = `<span>${event.ora} ${icon} ${event.nome}</span>`;
                eventBar.title = `(ARCHIVIATO) ${getEventName(event.evento)}\nüë§ ${event.nome}`;
                eventBar.onclick = (e) => {
                    e.stopPropagation();
                    showDetailsModal(event);
                };

                eventsContainer.appendChild(eventBar);
            });
        }
        daysEl.appendChild(dayEl);
    }
}

async function submitAdminBooking(event, isRetry = false) {
    if (event) event.preventDefault();
    const btn = document.getElementById('btn-admin-submit-booking');
    const form = document.getElementById('admin-new-booking');
    if (!form.checkValidity()) {
        showBanner('‚ùå Compila tutti i campi obbligatori', 'error');
        return;
    }

    const evento = document.getElementById('adminEvento').value;
    const isSpecialEvent = evento === 'compleanno' || evento === 'eventi';

    let finalNote = '';
    if (isSpecialEvent) {
        const personCount = document.getElementById('admin-person-count').value;
        const musicOption = document.querySelector('input[name="admin-music-option"]:checked').value;
        const tablesOption = document.querySelector('input[name="admin-tables-option"]:checked').value;
        const otherRequests = document.getElementById('admin-other-requests').value.trim();
        finalNote = `Dettagli Evento:\n- Numero Persone: ${personCount}\n- Impianto Musicale: ${musicOption}\n- Tavoli e Sedie: ${tablesOption}`;
        if (otherRequests) {
            finalNote += `\n- Altre Richieste: ${otherRequests}`;
        }
    } else {
        finalNote = document.getElementById('adminNote').value.trim();
    }

    const confirmCheckbox = document.getElementById('adminConfermaEvento');
    if (isSpecialEvent && confirmCheckbox && !confirmCheckbox.checked) {
        showBanner('‚ùå Devi confermare l\'evento speciale prima di procedere', 'error');
        return;
    }

    if (!isRetry) {
        btn.classList.add('loading');
        btn.disabled = true;
    }

    let campoValue = isSpecialEvent ? 'entrambi' : evento;
    let emailValue;
    const emailField = document.getElementById('adminEmail');
    if (isSpecialEvent && emailField && emailField.value.trim()) {
        emailValue = emailField.value.trim();
    } else {
        emailValue = 'prenotazionecampoanspi@gmail.com';
    }

    currentBooking = {
        id: `ANSPI-${generateShortId()}`,
        nome: document.getElementById('adminNome').value.trim(),
        email: emailValue,
        telefono: document.getElementById('adminTelefono').value.trim(),
        evento: evento,
        campo: campoValue,
        data: document.getElementById('adminData').value,
        ora: document.getElementById('adminOra').value,

        note: finalNote,
        ricorrente: !isSpecialEvent && document.getElementById('adminRicorrente').checked,
        adminActionBy: currentAdminEmail
    };
    try {
        const result = await makeRequest('createBooking', currentBooking);
        if (result.status === 'exclusive_conflict') {
            showExclusiveConflictModal(result);
        } else if (result.status === 'conflict_suggestions') {
            showConflictModal(result, 'admin');
        } else if (result.status === 'ok') {
            form.reset();
            toggleAdminCampoSelection();
            showBanner(`‚úÖ Prenotazione ${currentBooking.ricorrente ? 'ricorrente ' : ''}creata!`, 'success');
            await loadInitialData(true);
        } else if (result.status === 'updated') {
            form.reset();
            toggleAdminCampoSelection();
            showBanner('‚úÖ Prenotazione aggiornata con successo!', 'success');
            await loadInitialData(true);
        } else if (result.status === 'duplicate') {
            showBanner('‚ùå Esiste gi√† una prenotazione per questa data, ora e campo.', 'error');
        } else if (result.status === 'error') {
            showBanner(`‚ùå Errore: ${result.message}`, 'error');
        } else {
            showBanner(`‚ö†Ô∏è Risposta inattesa dal server: ${result.status}`, 'error');
        }
    } catch (error) {
        console.error("Creazione prenotazione admin fallita:", error);
        showBanner('‚ùå Errore di comunicazione con il server', 'error');
    } finally {
        btn.classList.remove('loading');
        btn.disabled = false;
    }
}

async function deleteBooking(bookingId) {
    showGenericConfirmModal('Conferma Cancellazione', `Sei sicuro di voler eliminare la prenotazione ${bookingId}? Se √® un evento master ricorrente, tutte le sue ripetizioni verranno cancellate.`, async () => {
        try {
            await makeRequest('deleteBooking', {
                bookingId
            });
            showBanner('‚úÖ Prenotazione eliminata', 'success');
            await loadInitialData(true);
        } catch (error) {}
    });
}

async function updateRecurring(bookingId, checkbox) {
    const isChecked = checkbox.checked;
    const question = isChecked ?
        `Sei sicuro di voler rendere questa prenotazione ricorrente?` : 
        `Sei sicuro di voler rimuovere la ricorrenza? Gli eventi futuri verranno eliminati.`;
        
    showGenericConfirmModal('Conferma Modifica', question, async () => {
        try {
            const result = await makeRequest('updateBookingDetail', {
                bookingId: bookingId,
                field: 'ricorrente',
                value: isChecked
            });
            
            if (!isChecked && result.data && result.data.deletedFutureEvents > 0) {
                showBanner(`‚úÖ Ricorrenza disabilitata! ${result.data.deletedFutureEvents} eventi eliminati`, 'success', 6000);
            } else if (isChecked) {
                showBanner('‚úÖ Ricorrenza abilitata! La prossima ricorrenza verr√† creata quando l\'evento termina', 'success', 6000);
            } else {
                showBanner('‚úÖ Ricorrenza disabilitata!', 'success');
            }
            
            // Forza refresh completo
            cache.bookings = null;
            cache.timestamp = null;
            await loadInitialData(true);
            
            // Aggiorna calendario
            if (document.getElementById('admin-calendar').style.display === 'block') {
                renderMonthlyCalendar();
            }
            
        } catch (e) {
            showBanner('‚ùå Errore aggiornamento', 'error');
            checkbox.checked = !checkbox.checked;
        }
    });
}

async function updateField(bookingId, select) {
    try {
        await makeRequest('updateBookingDetail', {
            bookingId: bookingId,
            field: 'campo',
            value: select.value
        });
        showBanner('Campo aggiornato!', 'success');
        const booking = bookings.find(b => b.id === bookingId);
        if (booking) booking.campo = select.value;
    } catch (e) {
        showBanner('Errore aggiornamento.', 'error');
    }
}

function getEventName(type) {
    return {
        calcetto: '‚öΩ Calcetto',
        pallavolo: 'üèê Pallavolo',
        compleanno: 'üéâ Compleanno',
        eventi: 'üé™ Evento Straordinario'
    } [type] ||
    type;
}

function getCampoName(type) {
    return {
        calcetto: 'Calcetto',
        pallavolo: 'Pallavolo',
        entrambi: 'Entrambi',
        'admin-managed': 'Da definire'
    } [type] || type;
}

function formatDate(dateStr) {
    if (!dateStr) return '';
    try {
        return new Date(dateStr.split('T')[0] + 'T00:00:00').toLocaleDateString('it-IT', {
            day: '2-digit',
            month: '2-digit',
            year: 'numeric'
        });
    } catch (e) {
        return dateStr;
    }
}

function closeModal(modalId) {
    document.getElementById(modalId).style.display = 'none';
}

function showBanner(message, type = 'info', duration = 4000) {
    const existingBanner = document.querySelector('.banner');
    if (existingBanner) existingBanner.remove();
    const banner = document.createElement('div');
    banner.className = `banner banner-${type}`;
    banner.innerHTML = message;
    document.body.appendChild(banner);
    setTimeout(() => {
        if (banner.parentNode) banner.remove();
    }, duration);
}

async function showTriggerInfo() {
    if (!isAdminLoggedIn) {
        showBanner('‚ùå Solo gli amministratori possono gestire i trigger', 'error');
        return;
    }

    const modal = document.getElementById('archiveModal');
    if (modal) {
        modal.style.display = 'block';
        setupArchiveModal();
    }
}

async function setupArchiveModal() {
    await checkTriggerStatus();

    document.getElementById('btn-create-trigger').addEventListener('click', createTrigger);
    document.getElementById('btn-delete-trigger').addEventListener('click', deleteTrigger);
    document.getElementById('btn-disable-all-triggers').addEventListener('click', disableAllTriggers);
}
/**
 * Controlla lo stato attuale dei trigger con nuovi stili moderni
 */
async function checkTriggerStatus() {
    const statusDiv = document.getElementById('trigger-status');
    const statusIcon = document.getElementById('trigger-status-icon');
    const statusTitle = document.getElementById('trigger-status-title');
    const statusSubtitle = document.getElementById('trigger-status-subtitle');
    
    if (!statusDiv || !statusIcon || !statusTitle || !statusSubtitle) return;
    
    // Applica stato di caricamento
    setTriggerStatus('loading', '‚è≥', 'Controllo stato trigger...', 'Verifica in corso...');
    
    try {
        const result = await makeRequest('getTriggerInfo');
        
        const isActive = result.active === true || (result.count !== undefined && result.count > 0);
        const triggerCount = result.count || 0;
        
        if (isActive && triggerCount > 0) {
            setTriggerStatus(
                'active', 
                '‚úÖ', 
                'Sistema Attivo', 
                `${triggerCount} trigger configurato ‚Ä¢ Esecuzione automatica a mezzanotte`
            );
        } else {
            setTriggerStatus(
                'inactive', 
                '‚ö†Ô∏è', 
                'Sistema Non Attivo', 
                'Nessun trigger configurato ‚Ä¢ Clicca "Attiva Trigger" per iniziare'
            );
        }
        
    } catch (error) {
        setTriggerStatus(
            'error', 
            '‚ùå', 
            'Errore di Connessione', 
            'Impossibile verificare lo stato ‚Ä¢ Riprova tra qualche istante'
        );
    }
}

function setTriggerStatus(status, icon, title, subtitle) {
    const statusDiv = document.getElementById('trigger-status');
    const statusIcon = document.getElementById('trigger-status-icon');
    const statusTitle = document.getElementById('trigger-status-title');
    const statusSubtitle = document.getElementById('trigger-status-subtitle');
    
    if (!statusDiv || !statusIcon || !statusTitle || !statusSubtitle) return;
    
    // Rimuovi classi di stato esistenti
    statusDiv.classList.remove('status-active', 'status-inactive', 'status-error', 'status-loading');
    
    // Applica nuovo stato
    statusDiv.classList.add(`status-${status}`);
    
    // Aggiorna contenuto
    statusIcon.textContent = icon;
    statusTitle.textContent = title;
    statusSubtitle.textContent = subtitle;
}

/**
 * Imposta lo stato del trigger con i nuovi stili
 */
function setTriggerStatus(status, icon, title, subtitle) {
    const statusDiv = document.getElementById('trigger-status');
    const statusIcon = document.getElementById('trigger-status-icon');
    const statusTitle = document.getElementById('trigger-status-title');
    const statusSubtitle = document.getElementById('trigger-status-subtitle');
    
    if (!statusDiv || !statusIcon || !statusTitle || !statusSubtitle) return;
    
    // Rimuovi tutte le classi di stato esistenti
    statusDiv.classList.remove('status-active', 'status-inactive', 'status-error', 'status-loading');
    
    // Aggiungi animazione di entrata
    statusDiv.classList.add('trigger-status-enter');
    
    // Applica nuovo stato
    statusDiv.classList.add(`status-${status}`);
    
    // Aggiorna contenuto
    statusIcon.textContent = icon;
    statusTitle.textContent = title;
    statusSubtitle.textContent = subtitle;
    
    // Rimuovi la classe di animazione dopo l'animazione
    setTimeout(() => {
        statusDiv.classList.remove('trigger-status-enter');
    }, 500);
}

/**
 * Attiva i trigger automatici (versione aggiornata)
 */
async function attivaTrigger() {
    console.log('üîµ attivaTrigger chiamata');
    const btn = document.getElementById('btn-attiva-trigger');
    if (!btn || btn.disabled) return;
    
    btn.classList.add('loading');
    btn.disabled = true;
    
    // Mostra stato di caricamento
    setTriggerStatus('loading', '‚ö°', 'Attivazione in corso...', 'Configurazione trigger automatici...');
    
    try {
        console.log('üì° Invio richiesta setupEventNotifications...');
        const result = await makeRequest('setupEventNotifications');
        console.log('üì• Risposta ricevuta:', result);
        
        if (result.status === 'ok') {
            showBanner(`‚úÖ Trigger di notifica attivati! (${result.data.triggersCreated} trigger creati, ${result.data.triggersDeleted} rimossi)`, 'success', 5000);
            await checkTriggerStatus();
        } else {
            showBanner(`‚ùå Errore attivazione: ${result.message}`, 'error');
            setTriggerStatus('error', '‚ùå', 'Errore Attivazione', result.message || 'Errore sconosciuto');
        }
        
    } catch (error) {
        console.error('‚ùå Errore attivazione trigger:', error);
        showBanner('‚ùå Errore di comunicazione durante l\'attivazione', 'error');
        setTriggerStatus('error', '‚ùå', 'Errore di Comunicazione', 'Impossibile attivare i trigger');
        
    } finally {
        btn.classList.remove('loading');
        btn.disabled = false;
    }
}

/**
 * Disattiva i trigger automatici (versione aggiornata)
 */
async function disattivaTrigger() {
    console.log('üî¥ disattivaTrigger chiamata');
    const btn = document.getElementById('btn-disattiva-trigger');
    if (!btn || btn.disabled) return;
    
    // USA IL MODAL PERSONALIZZATO invece del confirm()
    showGenericConfirmModal(
        'üïõ Disattiva Trigger Automatico', 
        'Sei sicuro di voler disattivare tutti i trigger automatici?\n\nIl sistema non eseguir√† pi√π archiviazioni e ricorrenze automatiche.',
        async () => {
            // TUTTO IL CODICE DI DISATTIVAZIONE VA QUI DENTRO
            btn.classList.add('loading');
            btn.disabled = true;
            
            // Mostra stato di caricamento
            setTriggerStatus('loading', '‚ö°', 'Disattivazione in corso...', 'Rimozione trigger automatici...');
            
            try {
                console.log('üì° Invio richiesta disableAllNotificationTriggers...');
                const result = await makeRequest('disableAllNotificationTriggers');
                console.log('üì• Risposta ricevuta:', result);
                
                if (result.status === 'ok') {
                    const deletedCount = result.deletedCount || 0;
                    showBanner(`‚úÖ Trigger disattivati con successo! (${deletedCount} trigger rimossi)`, 'success', 5000);
                    await checkTriggerStatus();
                } else {
                    showBanner(`‚ùå Errore disattivazione: ${result.message}`, 'error');
                    setTriggerStatus('error', '‚ùå', 'Errore Disattivazione', result.message || 'Errore sconosciuto');
                }
                
            } catch (error) {
                console.error('‚ùå Errore disattivazione trigger:', error);
                showBanner('‚ùå Errore di comunicazione durante la disattivazione', 'error');
                setTriggerStatus('error', '‚ùå', 'Errore di Comunicazione', 'Impossibile disattivare i trigger');
                
            } finally {
                btn.classList.remove('loading');
                btn.disabled = false;
            }
        }
    );
}

async function deleteTrigger() {
    if (!isAdminLoggedIn) {
        showBanner('‚ùå Solo gli amministratori possono eliminare trigger', 'error');
        return;
    }

    const btn = document.getElementById('btn-delete-trigger');
    const btnText = btn.querySelector('.btn-text');
    const btnLoading = btn.querySelector('.btn-loading');

    btn.disabled = true;
    btnText.style.display = 'none';
    btnLoading.style.display = 'inline';
    try {
        const result = await makeRequest('disableAllNotificationTriggers');
        if (result.status === 'ok') {
            showBanner(`‚úÖ Trigger di notifica disattivati! (${result.deletedCount} trigger rimossi: ${result.deletedTriggers.join(', ')})`, 'success');
            await checkTriggerStatus();
        } else {
            showBanner(`‚ùå Errore eliminazione trigger: ${result.message}`, 'error');
        }
    } catch (error) {
        console.error('‚ùå Errore durante l\'eliminazione trigger:', error);
        showBanner('‚ùå Errore durante l\'eliminazione del trigger', 'error');
    } finally {
        btn.disabled = false;
        btnText.style.display = 'inline';
        btnLoading.style.display = 'none';
    }
}

async function createTrigger() {
    if (!isAdminLoggedIn) {
        showBanner('‚ùå Solo gli amministratori possono attivare trigger', 'error');
        return;
    }

    const btn = document.getElementById('btn-create-trigger');
    const btnText = btn.querySelector('.btn-text');
    const btnLoading = btn.querySelector('.btn-loading');

    btn.disabled = true;
    btnText.style.display = 'none';
    btnLoading.style.display = 'inline';
    try {
        const result = await makeRequest('setupEventNotifications');
        if (result.status === 'ok') {
            showBanner(`‚úÖ Trigger di notifica attivati! (${result.data.triggersCreated} trigger creati, ${result.data.triggersDeleted} rimossi)`, 'success');
            await checkTriggerStatus();
        } else {
            showBanner(`‚ùå Errore attivazione trigger: ${result.message}`, 'error');
        }
    } catch (error) {
        console.error('‚ùå Errore durante l\'attivazione trigger:', error);
        showBanner('‚ùå Errore durante l\'attivazione dei trigger', 'error');
    } finally {
        btn.disabled = false;
        btnText.style.display = 'inline';
        btnLoading.style.display = 'none';
    }
}

async function disableAllTriggers() {
    if (!isAdminLoggedIn) {
        showBanner('‚ùå Solo gli amministratori possono disattivare trigger', 'error');
        return;
    }

    const btn = document.getElementById('btn-disable-all-triggers');
    const btnText = btn.querySelector('.btn-text');
    const btnLoading = btn.querySelector('.btn-loading');

    btn.disabled = true;
    btnText.style.display = 'none';
    btnLoading.style.display = 'inline';
    try {
        const result = await makeRequest('disableAllNotificationTriggers');
        if (result.status === 'ok') {
            showBanner(`‚úÖ Tutti i trigger di notifica disattivati! (${result.deletedCount} trigger rimossi: ${result.deletedTriggers.join(', ')})`, 'success');
            await checkTriggerStatus();
        } else {
            showBanner(`‚ùå Errore disattivazione trigger: ${result.message}`, 'error');
        }
    } catch (error) {
        console.error('‚ùå Errore durante la disattivazione trigger:', error);
        showBanner('‚ùå Errore durante la disattivazione dei trigger', 'error');
    } finally {
        btn.disabled = false;
        btnText.style.display = 'inline';
        btnLoading.style.display = 'none';
    }
}

function checkArchiveBanner() {
    console.log('üîç Controllo eventi passati...');
    console.log('üë§ Admin loggato:', isAdminLoggedIn);
    console.log('üìÖ Eventi dashboard (futuri):', bookings.length);
    console.log('üìÖ Eventi calendario (tutti):', calendarBookings.length);
    if (isAdminLoggedIn) {
        const dataSource = calendarBookings.length > 0 ?
            calendarBookings : bookings;
        console.log('üìä Usando fonte dati:', calendarBookings.length > 0 ? 'calendario' : 'dashboard');

        const now = new Date();
        console.log('üïê Data attuale:', now.toISOString());

        const pastEvents = dataSource.filter(booking => {
            const eventDateTime = new Date(booking.data + 'T' + booking.ora);
            console.log(`üìÖ Evento ${booking.id}: ${booking.data} ${booking.ora} -> ${eventDateTime.toISOString()}`);

            const isPast = eventDateTime < now;
            console.log(`‚è∞ √à
 passato? ${isPast}`);

            return isPast;
        });
        console.log('üì¶ Eventi passati trovati:', pastEvents.length);
        console.log('üìã Eventi passati:', pastEvents.map(e => `${e.id}: ${e.data} ${e.ora}`));
        if (pastEvents.length > 0) {
            console.log('‚úÖ Ci sono eventi da archiviare (banner mostrato manualmente)');
        } else {
            console.log('‚ö†Ô∏è Nessun evento passato trovato');
        }
    } else {
        console.log('‚ö†Ô∏è Non sei loggato come admin');
    }
}

async function testDateMathBtnClick(event) {
    const btn = event.target;
    btn.classList.add('loading');
    btn.disabled = true;
    try {
        const result = await makeRequest('testDateMath');
        if (result.status === 'ok') {
            showBanner(`‚úÖ Test completato - controlla i log`, 'success');
        } else {
            showBanner(`‚ùå Errore: ${result.message}`, 'error');
        }
    } catch (error) {
        showBanner('‚ùå Errore durante il test', 'error');
    } finally {
        btn.classList.remove('loading');
        btn.disabled = false;
    }
}

function getNextWeekDateString(dateStr) {
    try {
        let normalizedDate;
        if (dateStr instanceof Date) {
            normalizedDate = dateStr.toISOString().split('T')[0];
        } else if (typeof dateStr === 'number') {
            const dateObj = new Date(Math.round((dateStr - 25569) * 86400 * 1000));
            normalizedDate = dateObj.toISOString().split('T')[0];
        } else {
            normalizedDate = dateStr.trim();
        }

        const originalDate = new Date(normalizedDate + 'T12:00:00.000Z');
        if (isNaN(originalDate.getTime())) {
            console.log(`‚ùå Data non valida: ${dateStr}`);
            return dateStr;
        }

        const nextWeekDate = new Date(originalDate.getTime() + (7 * 24 * 60 * 60 * 1000));
        const result = nextWeekDate.toISOString().split('T')[0];

        console.log(`üìÖ Frontend: ${normalizedDate} ‚Üí ${result} (+7 giorni)`);

        return result;
    } catch (error) {
        console.log(`‚ùå Errore nel calcolo data frontend: ${error.message}`);
        return dateStr;
    }
}
async function testSmartRecurring(event) {
    const btn = event.target;
    btn.classList.add('loading');
    btn.disabled = true;
    
    try {
        showBanner('üîÑ Test sistema ricorrenze in corso...', 'info');
        
        // Prima testa la connessione
        const debugResult = await makeRequest('getDebugInfo');
        console.log('üîç Debug info:', debugResult);
        
        if (debugResult.status !== 'ok') {
            showBanner(`‚ùå Errore connessione: ${debugResult.message}`, 'error');
            return;
        }
        
        // Poi esegui il test del sistema
        const result = await makeRequest('testSmartRecurring');
        console.log('üß™ Test result:', result);
        
        if (result.status === 'ok') {
            const message = result.message || 'Test completato con successo';
            showBanner(`‚úÖ ${message}`, 'success');
            
            // Ricarica i dati del calendario
            await loadInitialData(true);
            
        } else {
            showBanner(`‚ùå Errore test: ${result.message}`, 'error');
        }
        
    } catch (error) {
        console.error('Errore test sistema ricorrenze:', error);
        showBanner('‚ùå Errore durante il test del sistema', 'error');
    } finally {
        btn.classList.remove('loading');
        btn.disabled = false;
    }
}

function generateShortId() {
    const now = new Date();
    const timeComponent = now.getHours() * 10000 + now.getMinutes() * 100 + now.getSeconds();
    const randomComponent = Math.floor(Math.random() * 100);
    const shortId = (timeComponent + randomComponent) % 100000;
    return shortId.toString().padStart(5, '0');
}

// ===================================================
// SCRIPT AGGIUNTIVO PER RICORRENZE INTELLIGENTI
// (Precedentemente in index.txt)
// ===================================================
// =====================================================
// FIX PER IL PANNELLO RICORRENZE INTELLIGENTI
// Sostituisci COMPLETAMENTE il codice nella sezione script
// che inizia con "setupSmartRecurringListeners"
// =====================================================

function setupSmartRecurringListeners() {
    // Test Sistema Ricorrenze
    const testBtn = document.getElementById('btn-test-smart-recurring');
    if (testBtn) {
        testBtn.addEventListener('click', async function(event) {
            const btn = event.target.closest('button');
            btn.classList.add('loading');
            btn.disabled = true;
            
            try {
                const result = await makeRequest('testSmartRecurring');
                if (result.success) {
                    showBanner('Test completato: ' + result.tests.length + ' test eseguiti, ' + result.summary.passed + ' successi', 'success', 6000);
                    await loadInitialData(true);
                    await checkSmartTriggerStatus();
                } else {
                    showBanner('Errore: ' + result.message, 'error');
                }
            } catch (error) {
                showBanner('Errore durante il test del sistema', 'error');
            } finally {
                btn.classList.remove('loading');
                btn.disabled = false;
            }
        });
    }
    
    // Setup Trigger
    const setupBtn = document.getElementById('btn-setup-smart-trigger');
    if (setupBtn) {
        setupBtn.addEventListener('click', async function(event) {
            const btn = event.target.closest('button');
            btn.classList.add('loading');
            btn.disabled = true;
            
            try {
                const result = await makeRequest('setupSmartTrigger');
                if (result.success) {
                    showBanner(result.message, 'success');
                    await checkSmartTriggerStatus();
                } else {
                    showBanner('Errore: ' + result.message, 'error');
                }
            } catch (error) {
                showBanner('Errore durante la configurazione del trigger', 'error');
            } finally {
                btn.classList.remove('loading');
                btn.disabled = false;
            }
        });
    }
    
    // Archiviazione Manuale (ora usa sistema intelligente)
    const archiveBtn = document.getElementById('btn-manual-archive');
    if (archiveBtn) {
        archiveBtn.addEventListener('click', async function(event) {
            const btn = event.target.closest('button');
            btn.classList.add('loading');
            btn.disabled = true;
            
            try {
                const result = await makeRequest('manualRecurringCheck');
                if (result.status === 'ok') {
                    showBanner('Processo completato: ' + result.data.generatedCount + ' ricorrenze generate, ' + result.data.archivedCount + ' eventi archiviati', 'success', 6000);
                    await loadInitialData(true);
                    await checkSmartTriggerStatus();
                } else {
                    showBanner('Errore: ' + result.message, 'error');
                }
            } catch (error) {
                showBanner('Errore durante il processo', 'error');
            } finally {
                btn.classList.remove('loading');
                btn.disabled = false;
            }
        });
    }
    
    // Pulizia Duplicati Ricorrenze
    const cleanupBtn = document.getElementById('btn-cleanup-duplicates');
    if (cleanupBtn) {
        cleanupBtn.addEventListener('click', async function(event) {
            const btn = event.target.closest('button');
            btn.classList.add('loading');
            btn.disabled = true;
            
            try {
                const result = await makeRequest('cleanupDuplicateRecurringEvents');
                if (result.status === 'ok') {
                    showBanner('Pulizia completata: ' + result.data.deletedCount + ' eventi duplicati eliminati', 'success', 6000);
                    await loadInitialData(true);
                } else {
                    showBanner('Errore: ' + result.message, 'error');
                }
            } catch (error) {
                showBanner('Errore durante la pulizia', 'error');
            } finally {
                btn.classList.remove('loading');
                btn.disabled = false;
            }
        });
    }
    
}
function checkSmartTriggerStatus() {
    const statusDiv = document.getElementById('smart-trigger-status');
    const statusText = document.getElementById('trigger-status-text');
    
    if (!statusDiv || !statusText) return;
    
    statusDiv.className = 'loading';
    statusText.textContent = 'Controllo stato...';
    
    makeRequest('getTriggerInfo')
        .then(function(result) {
            const isSuccess = result.success === true || result.active === true || (result.count !== undefined && result.count > 0);
            const triggerCount = result.count || 0;
            const message = result.message || 'Nessuna informazione disponibile';
            
            console.log('Risposta getTriggerInfo:', result);
            
            if (isSuccess && triggerCount > 0) {
                statusDiv.className = 'active';
                statusText.innerHTML = '<strong>Sistema Attivo</strong> - ' + triggerCount + ' trigger configurato/i';
            } else if (triggerCount === 0) {
                statusDiv.className = 'inactive';
                statusText.innerHTML = '<strong>Sistema Non Attivo</strong> - Nessun trigger configurato';
            } else {
                statusDiv.className = 'inactive';
                statusText.innerHTML = '<strong>Stato Indeterminato</strong> - ' + message;
            }
        })
        .catch(function(error) {
            console.error('Errore checkSmartTriggerStatus:', error);
            statusDiv.className = 'inactive';
            statusText.innerHTML = '<strong>Errore di Connessione</strong> - Impossibile verificare lo stato';
        });
}

function setupDebugTools() {
    // Debug Calendario
    const debugCalendarBtn = document.getElementById('btn-debug-calendar');
    if (debugCalendarBtn) {
        debugCalendarBtn.addEventListener('click', function() {
            const result = debugCalendarComplete();
            showBanner('Debug: ' + result.message, 'info', 4000);
        });
    }
    
    // Clear Cache
    const clearCacheBtn = document.getElementById('btn-clear-cache');
    if (clearCacheBtn) {
        clearCacheBtn.addEventListener('click', async function() {
            try {
                const result = await makeRequest('clearBookingsCache');
                if (result.status === 'ok') {
                    showBanner('Cache pulita con successo', 'success');
                    await loadInitialData(true);
                }
            } catch (error) {
                showBanner('Errore pulizia cache', 'error');
            }
        });
    }
    
    // Test Connessione
    const testSheetBtn = document.getElementById('btn-test-sheet');
    if (testSheetBtn) {
        testSheetBtn.addEventListener('click', async function(event) {
            const btn = event.target.closest('button');
            btn.classList.add('loading');
            btn.disabled = true;
            
            try {
                const timeoutPromise = new Promise(function(_, reject) {
                    setTimeout(function() { reject(new Error('Timeout test connessione')); }, 8000);
                });
                
                const testPromise = makeRequest('testSheetConnection');
                const result = await Promise.race([testPromise, timeoutPromise]);
                
                if (result.success) {
                    showBanner(result.message + ': ' + result.data.rows + ' righe', 'success');
                } else {
                    showBanner(result.message, 'error');
                }
            } catch (error) {
                console.error('Test connessione fallito:', error);
                if (error.message.includes('Timeout')) {
                    showBanner('Test connessione troppo lento - sistema probabilmente OK', 'warning', 6000);
                } else {
                    showBanner('Test connessione fallito', 'error');
                }
            } finally {
                btn.classList.remove('loading');
                btn.disabled = false;
            }
        });
    }
    
    // Test Telegram
    const testTelegramBtn = document.getElementById('btn-test-telegram');
    if (testTelegramBtn) {
        testTelegramBtn.addEventListener('click', async function(event) {
            const btn = event.target.closest('button');
            btn.classList.add('loading');
            btn.disabled = true;
            
            try {
                const result = await makeRequest('testTelegramNotification');
                if (result.status === 'ok') {
                    showBanner('Test Telegram inviato con successo', 'success');
                } else {
                    showBanner('Errore: ' + result.message, 'error');
                }
            } catch (error) {
                showBanner('Errore test Telegram', 'error');
            } finally {
                btn.classList.remove('loading');
                btn.disabled = false;
            }
        });
    }
    
    // Test Daily Summary
    const testDailySummaryBtn = document.getElementById('btn-test-daily-summary');
    if (testDailySummaryBtn) {
        testDailySummaryBtn.addEventListener('click', async function(event) {
            const btn = event.target.closest('button');
            btn.classList.add('loading');
            btn.disabled = true;
            
            try {
                const result = await makeRequest('testMarkDailySummary');
                if (result.status === 'ok') {
                    showBanner('Riepilogo simulato per oggi! Ora le prenotazioni di oggi attiveranno Telegram', 'success', 6000);
                } else {
                    showBanner('Errore: ' + result.message, 'error');
                }
            } catch (error) {
                showBanner('Errore test riepilogo', 'error');
            } finally {
                btn.classList.remove('loading');
                btn.disabled = false;
            }
        });
    }
}

// Inizializza al caricamento
document.addEventListener('DOMContentLoaded', function() {
    setupSmartRecurringListeners();
    
    if (typeof isAdminLoggedIn !== 'undefined' && isAdminLoggedIn) {
        checkSmartTriggerStatus();
    }
});

// === FUNZIONI GESTIONE ADMIN ===

let selectedAdminEmail = null;

/**
 * Verifica se l'admin corrente √® il master admin
 */
function isMasterAdmin(email) {
    return email && email.toLowerCase().trim() === 'prenotazionecampoanspi@gmail.com';
}

/**
 * Mostra/nasconde le sezioni admin master in base al tipo di admin
 */
function updateAdminManagementVisibility() {
    const section = document.getElementById('admin-management-section');
    const body = document.body;
    
    // Controlla se √® master admin
    const isMaster = currentAdminEmail && currentAdminEmail.toLowerCase() === 'prenotazionecampoanspi@gmail.com';
    
    if (isMaster) {
        body.classList.add('master-admin');
        if (section) {
            section.style.display = 'block';
            loadAdminsTable();
        }
        
        // Mostra badge master admin nel titolo
        updateMasterAdminBadge(true);
        
        // Mostra tutti gli elementi con classe admin-master-only
        document.querySelectorAll('.admin-master-only').forEach(element => {
            element.style.display = ''; // Revert to CSS default or block
        });
        
        console.log('üëë Master admin loggato - tutte le sezioni visibili');
    } else {
        body.classList.remove('master-admin');
        if (section) {
            section.style.display = 'none';
        }
        
        // Nascondi anche tutti gli elementi con classe admin-master-only
        document.querySelectorAll('.admin-master-only').forEach(element => {
            element.style.display = 'none';
        });
        
        updateMasterAdminBadge(false);
        
        console.log('üë§ Admin normale loggato - sezioni avanzate nascoste');
    }
}

/**
 * Aggiorna il badge master admin nell'interfaccia
 */
function updateMasterAdminBadge(isMaster) {
    // Rimuovi badge esistenti
    const existingBadges = document.querySelectorAll('.master-admin-status-badge');
    existingBadges.forEach(badge => badge.remove());
    
    if (isMaster) {
        // Aggiungi badge nel titolo dell'area admin
        const adminTitle = document.querySelector('#adminPanel .admin-tabs');
        if (adminTitle) {
            const badge = document.createElement('div');
            badge.className = 'master-admin-status-badge';
            badge.style.cssText = `
                position: absolute;
                top: -10px;
                right: 10px;
                background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
                color: white;
                padding: 6px 12px;
                border-radius: 15px;
                font-size: 0.8rem;
                font-weight: bold;
                z-index: 100;
                box-shadow: 0 2px 8px rgba(220, 53, 69, 0.3);
            `;
            badge.innerHTML = 'üëë MASTER ADMIN';
            adminTitle.appendChild(badge);
        }
    }
}

/**
 * Carica la lista degli admin
 */
async function loadAdminsList() {
    try {
        const result = await makeRequest('getAllAdmins');
        if (result.status === 'ok') {
            renderAdminsList(result.data.admins);
        } else {
            showBanner(`‚ùå Errore nel caricamento admin: ${result.message}`, 'error');
        }
    } catch (error) {
        showBanner('‚ùå Errore di comunicazione con il server', 'error');
    }
}

/**
 * Renderizza la lista degli admin
 */
function renderAdminsList(admins) {
    const adminsListDiv = document.getElementById('admins-list');
    if (!adminsListDiv) return;
    
    if (admins.length === 0) {
        adminsListDiv.innerHTML = '<p>Nessun admin trovato.</p>';
        return;
    }
    
    const adminsHtml = admins.map(admin => {
        const statusBadge = admin.hasPassword ? 
            '<span style="color: #28a745;">‚úÖ Password impostata</span>' : 
            '<span style="color: #ffc107;">‚ö†Ô∏è Password da impostare</span>';
        
        const masterBadge = admin.isMaster ? 
            '<span style="color: #dc3545; font-weight: bold;">üëë MASTER</span>' : '';
        
        const selectableClass = admin.isMaster ? '' : 'admin-selectable';
        const selectableStyle = admin.isMaster ? '' : 'cursor: pointer; border: 2px solid transparent;';
        
        return `
            <div class="admin-item ${selectableClass}" 
                 data-email="${admin.email}" 
                 style="background: rgba(255,255,255,0.05); padding: 15px; margin-bottom: 10px; border-radius: 5px; ${selectableStyle}">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <strong style="color: white;">${admin.email}</strong>
                        <div style="margin-top: 5px;">
                            ${statusBadge} ${masterBadge}
                        </div>
                    </div>
                    ${!admin.isMaster ? '<button class="btn btn-sm" onclick="selectAdmin(\'' + admin.email + '\')" style="padding: 5px 10px; font-size: 0.8rem;">Seleziona</button>' : ''}
                </div>
            </div>
        `;
    }).join('');
    
    adminsListDiv.innerHTML = adminsHtml;
}

/**
 * Seleziona un admin per le azioni
 */
function selectAdmin(email) {
    selectedAdminEmail = email;
    
    // Aggiorna stile degli elementi
    document.querySelectorAll('.admin-item').forEach(item => {
        item.style.border = '2px solid transparent';
    });
    
    const selectedItem = document.querySelector(`[data-email="${email}"]`);
    if (selectedItem) {
        selectedItem.style.border = '2px solid #007bff';
    }
    
    // Abilita i pulsanti di azione
    document.getElementById('btn-reset-password').disabled = false;
    document.getElementById('btn-remove-admin').disabled = false;
    
    showBanner(`‚úÖ Admin selezionato: ${email}`, 'success', 2000);
}

/**
 * Handler per aggiungere un nuovo admin
 */
async function addNewAdminHandler() {
    const email = document.getElementById('new-admin-email').value.trim();
    
    if (!email || !email.includes('@')) {
        showBanner('‚ùå Inserisci un\'email valida', 'error');
        return;
    }
    
    const btn = document.getElementById('btn-add-admin');
    btn.classList.add('loading');
    btn.disabled = true;
    
    try {
        const result = await makeRequest('addNewAdmin', {
            masterEmail: currentAdminEmail,
            newAdminEmail: email
        });
        
        if (result.status === 'ok') {
            showBanner(`‚úÖ ${result.message}`, 'success');
            document.getElementById('new-admin-email').value = '';
            loadAdminsList(); // Ricarica la lista
        } else {
            showBanner(`‚ùå Errore: ${result.message}`, 'error');
        }
    } catch (error) {
        showBanner('‚ùå Errore di comunicazione con il server', 'error');
    } finally {
        btn.classList.remove('loading');
        btn.disabled = false;
    }
}

/**
 * Handler per resettare la password di un admin
 */
async function resetAdminPasswordHandler() {
    if (!selectedAdminEmail) {
        showBanner('‚ùå Seleziona prima un admin', 'error');
        return;
    }
    
    if (!confirm(`Sei sicuro di voler resettare la password per ${selectedAdminEmail}?`)) {
        return;
    }
    
    const btn = document.getElementById('btn-reset-password');
    btn.classList.add('loading');
    btn.disabled = true;
    
    try {
        const result = await makeRequest('resetAdminPassword', {
            masterEmail: currentAdminEmail,
            adminEmailToReset: selectedAdminEmail
        });
        
        if (result.status === 'ok') {
            showBanner(`‚úÖ ${result.message}`, 'success');
            loadAdminsList(); // Ricarica la lista
        } else {
            showBanner(`‚ùå Errore: ${result.message}`, 'error');
        }
    } catch (error) {
        showBanner('‚ùå Errore di comunicazione con il server', 'error');
    } finally {
        btn.classList.remove('loading');
        btn.disabled = false;
    }
}

/**
 * Handler per rimuovere un admin
 */
async function removeAdminHandler() {
    if (!selectedAdminEmail) {
        showBanner('‚ùå Seleziona prima un admin', 'error');
        return;
    }
    
    if (!confirm(`Sei sicuro di voler rimuovere l'admin ${selectedAdminEmail}? Questa azione non pu√≤ essere annullata.`)) {
        return;
    }
    
    const btn = document.getElementById('btn-remove-admin');
    btn.classList.add('loading');
    btn.disabled = true;
    
    try {
        const result = await makeRequest('removeAdmin', {
            masterEmail: currentAdminEmail,
            adminEmailToRemove: selectedAdminEmail
        });
        
        if (result.status === 'ok') {
            showBanner(`‚úÖ ${result.message}`, 'success');
            selectedAdminEmail = null;
            loadAdminsList(); // Ricarica la lista
            
            // Disabilita i pulsanti
            document.getElementById('btn-reset-password').disabled = true;
            document.getElementById('btn-remove-admin').disabled = true;
        } else {
            showBanner(`‚ùå Errore: ${result.message}`, 'error');
        }
    } catch (error) {
        showBanner('‚ùå Errore di comunicazione con il server', 'error');
    } finally {
        btn.classList.remove('loading');
        btn.disabled = false;
    }
}

// Carica gli admin nella tabella
async function loadAdminsTable() {
    try {
        const result = await makeRequest('getAllAdmins');
        if (result.status === 'ok') {
            renderAdminsTable(result.data.admins);
        }
    } catch (error) {
        console.error('Errore caricamento admin:', error);
        showBanner('‚ùå Errore caricamento lista admin', 'error');
    }
}

// Renderizza la tabella admin
function renderAdminsTable(admins) {
    const tbody = document.querySelector('#admin-table tbody');
    if (!tbody) return;
    
    if (admins.length === 0) {
        tbody.innerHTML = '<tr><td colspan="3" style="text-align: center;">Nessun admin trovato</td></tr>';
        return;
    }
    
    tbody.innerHTML = '';
    
    admins.forEach(admin => {
        const isMaster = admin.email.toLowerCase() === 'prenotazionecampoanspi@gmail.com';
        const row = document.createElement('tr');
        
        // Colonna Email
        const emailCell = document.createElement('td');
        emailCell.innerHTML = admin.email + (isMaster ? ' <span style="color: #dc3545;">üëë MASTER</span>' : '');
        row.appendChild(emailCell);
        
        // Colonna Nome
        const nameCell = document.createElement('td');
        nameCell.textContent = admin.nome || '-';
        row.appendChild(nameCell);
        
        // Colonna Azioni
        const actionsCell = document.createElement('td');
        if (!isMaster) {
            actionsCell.innerHTML = `
                <button class="btn btn-warning btn-sm" onclick="resetAdminPassword('${admin.email}')" style="margin-right: 5px;">
                    üîë Reset Password
                </button>
                <button class="btn btn-danger btn-sm" onclick="confirmDeleteAdmin('${admin.email}')">
                    üóëÔ∏è Rimuovi
                </button>
            `;
        } else {
            actionsCell.innerHTML = '<span style="color: #6c757d;">Non modificabile</span>';
        }
        row.appendChild(actionsCell);
        
        tbody.appendChild(row);
    });
}

// Reset password admin
async function resetAdminPassword(email) {
    if (!confirm(`Resettare la password per ${email}?`)) {
        return;
    }
    
    try {
        const result = await makeRequest('resetAdminPassword', {
            masterEmail: currentAdminEmail,
            adminEmailToReset: email
        });
        
        if (result.status === 'ok') {
            showBanner(`‚úÖ ${result.message}`, 'success');
            loadAdminsTable();
        } else {
            showBanner(`‚ùå ${result.message}`, 'error');
        }
    } catch (error) {
        showBanner('‚ùå Errore reset password', 'error');
    }
}

// Mostra modale conferma eliminazione
function confirmDeleteAdmin(email) {
    selectedAdminForDelete = email;
    const modal = document.getElementById('confirm-delete-admin-modal');
    const text = document.getElementById('confirm-delete-admin-text');
    text.textContent = `Sei sicuro di voler rimuovere l'admin ${email}? Questa azione non pu√≤ essere annullata.`;
    modal.style.display = 'block';
}

// Chiudi modale eliminazione
function closeDeleteAdminModal() {
    const modal = document.getElementById('confirm-delete-admin-modal');
    modal.style.display = 'none';
    selectedAdminForDelete = null;
}
// Setup event listeners per il form di aggiunta admin
document.addEventListener('DOMContentLoaded', function() {
    // Form aggiunta admin
    const addAdminForm = document.getElementById('add-admin-form');
    if (addAdminForm) {
        addAdminForm.addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const email = document.getElementById('new-admin-email').value.trim();
            const nome = document.getElementById('new-admin-nome').value.trim();
            
            if (!email || !email.includes('@')) {
                showBanner('‚ùå Inserisci un\'email valida', 'error');
                return;
            }
            
            try {
                const result = await makeRequest('addNewAdmin', {
                    masterEmail: currentAdminEmail,
                    newAdminEmail: email,
                    nome: nome
                });
                
                if (result.status === 'ok') {
                    showBanner(`‚úÖ ${result.message}`, 'success');
                    addAdminForm.reset();
                    loadAdminsTable();
                } else {
                    showBanner(`‚ùå ${result.message}`, 'error');
                }
            } catch (error) {
                showBanner('‚ùå Errore aggiunta admin', 'error');
            }
        });
    }
    
    // Pulsante conferma eliminazione
    const confirmDeleteBtn = document.getElementById('confirm-delete-admin-btn');
    if (confirmDeleteBtn) {
        confirmDeleteBtn.addEventListener('click', async function() {
            if (!selectedAdminForDelete) return;
            
            try {
                const result = await makeRequest('removeAdmin', {
                    masterEmail: currentAdminEmail,
                    adminEmailToRemove: selectedAdminForDelete
                });
                
                if (result.status === 'ok') {
                    showBanner(`‚úÖ ${result.message}`, 'success');
                    closeDeleteAdminModal();
                    loadAdminsTable();
                } else {
                    showBanner(`‚ùå ${result.message}`, 'error');
                }
            } catch (error) {
                showBanner('‚ùå Errore rimozione admin', 'error');
            }
        });
    }
});

// =====================
// SETUP EVENT LISTENERS TRIGGER
// =====================
function setupTriggerEventListeners() {
    const btnAttiva = document.getElementById('btn-attiva-trigger');
    const btnDisattiva = document.getElementById('btn-disattiva-trigger');
    
    if (btnAttiva) {
        btnAttiva.removeEventListener('click', attivaTrigger); // Rimuovi listener duplicati
        btnAttiva.addEventListener('click', attivaTrigger);
        console.log('‚úÖ Event listener attiva trigger collegato');
    }
    
    if (btnDisattiva) {
        btnDisattiva.removeEventListener('click', disattivaTrigger); // Rimuovi listener duplicati  
        btnDisattiva.addEventListener('click', disattivaTrigger);
        console.log('‚úÖ Event listener disattiva trigger collegato');
    }
}

// =====================
// FUNZIONI TRIGGER
// =====================
async function attivaTrigger() {
    console.log('üîµ attivaTrigger chiamata');
    const btn = document.getElementById('btn-attiva-trigger');
    if (!btn || btn.disabled) return;
    
    btn.classList.add('loading');
    btn.disabled = true;
    
    try {
        console.log('üì° Invio richiesta setupEventNotifications...');
        const result = await makeRequest('setupEventNotifications');
        console.log('üì• Risposta ricevuta:', result);
        
        if (result.status === 'ok') {
            showBanner(`‚úÖ Trigger di notifica attivati! (${result.data.triggersCreated} trigger creati, ${result.data.triggersDeleted} rimossi)`, 'success', 5000);
            await checkTriggerStatus();
        } else {
            showBanner(`‚ùå Errore: ${result.message}`, 'error');
        }
        
    } catch (error) {
        console.error('‚ùå Errore attivazione trigger:', error);
        showBanner('‚ùå Errore di comunicazione', 'error');
        
    } finally {
        btn.classList.remove('loading');
        btn.disabled = false;
    }
}

async function disattivaTrigger() {
    console.log('üî¥ disattivaTrigger chiamata');
    const btn = document.getElementById('btn-disattiva-trigger');
    if (!btn || btn.disabled) return;
    
      
    btn.classList.add('loading');
    btn.disabled = true;
    
    try {
        console.log('üì° Invio richiesta disableAllNotificationTriggers...');
        const result = await makeRequest('disableAllNotificationTriggers');
        console.log('üì• Risposta ricevuta:', result);
        
        if (result.status === 'ok') {
            showBanner(`‚úÖ Trigger di notifica disattivati! (${result.deletedCount || 0} trigger rimossi: ${result.deletedTriggers.join(', ')})`, 'success', 5000);
            await checkTriggerStatus();
        } else {
            showBanner(`‚ùå Errore: ${result.message}`, 'error');
        }
        
    } catch (error) {
        console.error('‚ùå Errore disattivazione trigger:', error);
        showBanner('‚ùå Errore di comunicazione', 'error');
        
    } finally {
        btn.classList.remove('loading');
        btn.disabled = false;
    }
}

// =====================
// GESTIONE TRIGGER AUTOMATICO - PRODUZIONE
// =====================

/**
 * Controlla lo stato attuale dei trigger
 */
async function checkTriggerStatus() {
    const statusDiv = document.getElementById('trigger-status');
    const statusText = document.getElementById('trigger-status-text');
    
    if (!statusDiv || !statusText) return;
    
    // Stile base migliorato
    statusDiv.style.cssText = `
        margin: 15px 0; 
        padding: 18px 20px; 
        border-radius: 12px; 
        font-size: 0.95rem; 
        position: relative;
        overflow: hidden;
        transition: all 0.3s ease;
    `;
    
    try {
        const result = await makeRequest('getTriggerInfo');
        
        const isActive = result.active === true || (result.count !== undefined && result.count > 0);
        const triggerCount = result.count || 0;
        
        if (isActive && triggerCount > 0) {
            // Sistema attivo - Stile verde
            statusDiv.style.background = 'linear-gradient(135deg, rgba(40, 167, 69, 0.15) 0%, rgba(0, 184, 148, 0.1) 100%)';
            statusDiv.style.border = '2px solid rgba(40, 167, 69, 0.4)';
            statusDiv.style.color = '#28a745';
            statusDiv.style.boxShadow = '0 4px 15px rgba(40, 167, 69, 0.2)';
            
            statusDiv.innerHTML = `
                <div style="display: flex; align-items: center; gap: 12px;">
                    <div style="font-size: 1.5rem;">‚úÖ</div>
                    <div>
                        <strong style="font-size: 1rem; letter-spacing: 0.5px;">Sistema Attivo</strong>
                        <div style="font-size: 0.85rem; opacity: 0.9; margin-top: 2px;">
                            ${triggerCount} trigger configurato${triggerCount > 1 ? '/i' : ''} ‚Ä¢ Esecuzione automatica a mezzanotte
                        </div>
                    </div>
                </div>
            `;
        } else {
            // Sistema non attivo - Stile giallo
            statusDiv.style.background = 'linear-gradient(135deg, rgba(255, 193, 7, 0.15) 0%, rgba(253, 203, 110, 0.1) 100%)';
            statusDiv.style.border = '2px solid rgba(255, 193, 7, 0.4)';
            statusDiv.style.color = '#ffc107';
            statusDiv.style.boxShadow = '0 4px 15px rgba(255, 193, 7, 0.2)';
            
            statusDiv.innerHTML = `
                <div style="display: flex; align-items: center; gap: 12px;">
                    <div style="font-size: 1.5rem;">‚ö†Ô∏è</div>
                    <div>
                        <strong style="font-size: 1rem; letter-spacing: 0.5px;">Sistema Non Attivo</strong>
                        <div style="font-size: 0.85rem; opacity: 0.9; margin-top: 2px;">
                            Nessun trigger configurato ‚Ä¢ Clicca "Attiva Trigger" per iniziare
                        </div>
                    </div>
                </div>
            `;
        }
        
    } catch (error) {
        console.error('Errore controllo trigger:', error);
        
        // Stato errore - Stile rosso
        statusDiv.style.background = 'linear-gradient(135deg, rgba(220, 53, 69, 0.15) 0%, rgba(255, 107, 107, 0.1) 100%)';
        statusDiv.style.border = '2px solid rgba(220, 53, 69, 0.4)';
        statusDiv.style.color = '#dc3545';
        statusDiv.style.boxShadow = '0 4px 15px rgba(220, 53, 69, 0.2)';
        
        statusDiv.innerHTML = `
            <div style="display: flex; align-items: center; gap: 12px;">
                <div style="font-size: 1.5rem;">‚ùå</div>
                <div>
                    <strong style="font-size: 1rem; letter-spacing: 0.5px;">Errore di Connessione</strong>
                    <div style="font-size: 0.85rem; opacity: 0.9; margin-top: 2px;">
                        Impossibile verificare lo stato ‚Ä¢ Riprova tra qualche istante
                    </div>
                </div>
            </div>
        `;
    }
}

/**
 * Attiva i trigger automatici
 */
async function attivaTrigger() {
    console.log('üîµ attivaTrigger chiamata');
    const btn = document.getElementById('btn-attiva-trigger');
    if (!btn || btn.disabled) return;
    
    btn.classList.add('loading');
    btn.disabled = true;
    
    try {
        console.log('üì° Invio richiesta setupEventNotifications...');
        const result = await makeRequest('setupEventNotifications');
        console.log('üì• Risposta ricevuta:', result);
        
        if (result.status === 'ok') {
            showBanner(`‚úÖ Trigger di notifica attivati! (${result.data.triggersCreated} trigger creati, ${result.data.triggersDeleted} rimossi)`, 'success', 5000);
            await checkTriggerStatus();
        } else {
            showBanner(`‚ùå Errore attivazione: ${result.message}`, 'error');
        }
        
    } catch (error) {
        console.error('‚ùå Errore attivazione trigger:', error);
        showBanner('‚ùå Errore di comunicazione durante l\'attivazione', 'error');
        
    } finally {
        btn.classList.remove('loading');
        btn.disabled = false;
    }
}

/**
 * Disattiva i trigger automatici
 */
async function disattivaTrigger() {
    console.log('üî¥ disattivaTrigger chiamata');
    const btn = document.getElementById('btn-disattiva-trigger');
    if (!btn || btn.disabled) return;
    
    // Conferma dell'utente
    if (!confirm('Sei sicuro di voler disattivare tutti i trigger automatici?\n\nIl sistema non eseguir√† pi√π archiviazioni e ricorrenze automatiche.')) {
        return;
    }
    
    btn.classList.add('loading');
    btn.disabled = true;
    
    try {
        console.log('üì° Invio richiesta disableAllNotificationTriggers...');
        const result = await makeRequest('disableAllNotificationTriggers');
        console.log('üì• Risposta ricevuta:', result);
        
        if (result.status === 'ok') {
            const deletedCount = result.deletedCount || 0;
            showBanner(`‚úÖ Trigger di notifica disattivati con successo! (${deletedCount} trigger rimossi: ${result.deletedTriggers.join(', ')})`, 'success', 5000);
            await checkTriggerStatus();
        } else {
            showBanner(`‚ùå Errore disattivazione: ${result.message}`, 'error');
        }
        
    } catch (error) {
        console.error('‚ùå Errore disattivazione trigger:', error);
        showBanner('‚ùå Errore di comunicazione durante la disattivazione', 'error');
        
    } finally {
        btn.classList.remove('loading');
        btn.disabled = false;
    }
}

/**
 * Test manuale del sistema trigger
 */
async function testTriggerManuale() {
    const btn = document.getElementById('btn-test-trigger');
    if (!btn || btn.disabled) return;
    
    btn.classList.add('loading');
    btn.disabled = true;
    
    try {
        const result = await makeRequest('manualRecurringCheck');
        
        if (result.status === 'ok') {
            const generated = result.data?.generatedCount || 0;
            const archived = result.data?.archivedCount || 0;
            showBanner(`‚úÖ Test completato: ${generated} ricorrenze generate, ${archived} eventi archiviati`, 'success', 6000);
            
            // Forza refresh dei dati
            await loadInitialData(true);
        } else {
            showBanner(`‚ùå Errore test: ${result.message}`, 'error');
        }
        
    } catch (error) {
        console.error('Errore test trigger:', error);
        showBanner('‚ùå Errore durante il test manuale', 'error');
        
    } finally {
        btn.classList.remove('loading');
        btn.disabled = false;
    }
}

/**
 * Pulizia forzata del sistema
 */
async function forzaPulizia() {
    const btn = document.getElementById('btn-force-cleanup');
    if (!btn || btn.disabled) return;
    
    if (!confirm('Eseguire pulizia forzata del sistema?\n\nQuesta operazione rimuover√† cache e duplicate.')) {
        return;
    }
    
    btn.classList.add('loading');
    btn.disabled = true;
    
    try {
        // Pulisci cache
        await makeRequest('clearAllCaches');
        
        // Pulisci eventuali duplicati
        await makeRequest('cleanupDuplicateRecurringEvents');
        
        showBanner('‚úÖ Pulizia forzata completata con successo', 'success');
        
        // Forza refresh completo
        await loadInitialData(true);
        await checkTriggerStatus();
        
    } catch (error) {
        console.error('Errore pulizia forzata:', error);
        showBanner('‚ùå Errore durante la pulizia forzata', 'error');
        
    } finally {
        btn.classList.remove('loading');
        btn.disabled = false;
    }
}

/**
 * Setup event listeners per la gestione trigger
 */
function setupTriggerManagement() {
    // Event listeners principali
    const btnAttiva = document.getElementById('btn-attiva-trigger');
    const btnDisattiva = document.getElementById('btn-disattiva-trigger');
    const btnTest = document.getElementById('btn-test-trigger');
    const btnCleanup = document.getElementById('btn-force-cleanup');
    
    if (btnAttiva) {
        btnAttiva.addEventListener('click', attivaTrigger);
    }
    
    if (btnDisattiva) {
        btnDisattiva.addEventListener('click', disattivaTrigger);
    }
    
    if (btnTest) {
        btnTest.addEventListener('click', testTriggerManuale);
    }
    
    if (btnCleanup) {
        btnCleanup.addEventListener('click', forzaPulizia);
    }
    
    // Mostra/nascondi debug panel in base all'admin
    const debugPanel = document.getElementById('trigger-debug-panel');
    if (debugPanel && currentAdminEmail && currentAdminEmail.toLowerCase() === 'prenotazionecampoanspi@gmail.com') {
        debugPanel.style.display = 'block';
    }
}



/**
 * Inizializzazione al caricamento della pagina
 */
document.addEventListener('DOMContentLoaded', function() {
    // Setup immediato se siamo gi√† nella sezione giusta
    if (typeof isAdminLoggedIn !== 'undefined' && isAdminLoggedIn) {
        const gestioneCampoTab = document.getElementById('admin-gestione-campo');
        if (gestioneCampoTab && gestioneCampoTab.style.display === 'block') {
            setupTriggerManagement();
            checkTriggerStatus();
        }
    }
});
// =====================
// CALENDARIO PUBBLICO - SISTEMA COMPLETO CON FIX ALLINEAMENTO
// =====================

// Variabili globali per calendario pubblico
let publicCalendarDate = new Date();
let calendarInitialized = false;
let isCalendarUpdating = false;

/**
 * Inizializza il calendario pubblico con gestione robu—Å—Ç–∞
 */
function initializePublicCalendar() {
    console.log('üóìÔ∏è Inizializzazione calendario pubblico...');
    
    // Resetta lo stato
    calendarInitialized = false;
    isCalendarUpdating = false;
    
    // Imposta la data corrente se non √® gi√† stata impostata
    if (!publicCalendarDate || isNaN(publicCalendarDate.getTime())) {
        publicCalendarDate = new Date();
    }
    
    // Forza il primo giorno del mese per evitare problemi di offset
    publicCalendarDate.setDate(1);
    
    console.log('üìÖ Data calendario pubblico impostata:', publicCalendarDate.toISOString());
    
    // Setup listeners e renderizza
    setupPublicCalendarListeners();
    renderPublicCalendar();
    
    // Marca come inizializzato
    calendarInitialized = true;
    
    console.log('‚úÖ Calendario pubblico inizializzato correttamente');
}

/**
 * Setup event listeners per calendario pubblico - VERSIONE SEMPLIFICATA
 */
function setupPublicCalendarListeners() {
    console.log('üîß Setup listener calendario...');
    
    const prevBtn = document.getElementById('publicPrevMonth');
    const nextBtn = document.getElementById('publicNextMonth');
    
    if (prevBtn) {
        // Rimuovi listener esistenti clonando
        const newPrevBtn = prevBtn.cloneNode(true);
        prevBtn.parentNode.replaceChild(newPrevBtn, prevBtn);
        
        // Nuovo listener
        document.getElementById('publicPrevMonth').addEventListener('click', function(e) {
            e.preventDefault();
            console.log('‚¨ÖÔ∏è CLICK freccia sinistra');
            navigatePublicMonth(-1);
        });
        console.log('‚úÖ Listener precedente aggiunto');
    }
    
    if (nextBtn) {
        // Rimuovi listener esistenti clonando
        const newNextBtn = nextBtn.cloneNode(true);
        nextBtn.parentNode.replaceChild(newNextBtn, nextBtn);
        
        // Nuovo listener
        document.getElementById('publicNextMonth').addEventListener('click', function(e) {
            e.preventDefault();
            console.log('‚û°Ô∏è CLICK freccia destra');
            navigatePublicMonth(1);
        });
        console.log('‚úÖ Listener successivo aggiunto');
    }
    
    if (!prevBtn || !nextBtn) {
        console.error('‚ùå Pulsanti non trovati:', {prev: !!prevBtn, next: !!nextBtn});
        return;
    }
    
    console.log('‚úÖ Setup listeners completato');
}

/**
 * Navigazione mesi con fix robusto per bug setMonth() - VERSIONE SEMPLIFICATA
 */
function navigatePublicMonth(direction) {
    console.log(`üéØ CLICK navigazione: ${direction > 0 ? 'avanti' : 'indietro'}`);
    
    const currentYear = publicCalendarDate.getFullYear();
    const currentMonth = publicCalendarDate.getMonth();
    
    console.log(`üìÖ DA: ${currentMonth + 1}/${currentYear}`);
    
    // ‚úÖ FIX PER BUG setMonth(): Usa anno e mese separati
    let newYear = currentYear;
    let newMonth = currentMonth + direction;
    
    // Gestisci overflow/underflow dei mesi
    if (newMonth > 11) {
        newYear++;
        newMonth = 0;
    } else if (newMonth < 0) {
        newYear--;
        newMonth = 11;
    }
    
    // Crea nuova data SEMPRE con giorno 1
    publicCalendarDate = new Date(newYear, newMonth, 1);
    
    console.log(`üìÖ A: ${newMonth + 1}/${newYear}`);
    console.log('üìÖ Data impostata:', publicCalendarDate.toISOString());
    
    // Rigenera immediatamente
    renderPublicCalendar();
    
    console.log('‚úÖ Navigazione completata');
}

/**
 * Renderizza il calendario pubblico con eventi dettagliati e allineamento corretto
 */
function renderPublicCalendar() {
    if (isCalendarUpdating) {
        console.log('‚è≥ Calendario gi√† in aggiornamento, saltando...');
        return;
    }
    
    isCalendarUpdating = true;
    
    try {
        const month = publicCalendarDate.getMonth();
        const year = publicCalendarDate.getFullYear();
        
        console.log(`üìä Generando calendario pubblico per: ${month + 1}/${year}`);
        
        // Aggiorna titolo mese
        const titleEl = document.getElementById('publicMonthYear');
        if (titleEl) {
            titleEl.textContent = new Date(year, month).toLocaleString("it-IT", {month:"long", year:"numeric"});
        }
        
        // Renderizza intestazioni giorni
        const weekdaysEl = document.getElementById('publicCalendarWeekdays');
        if (weekdaysEl && weekdaysEl.children.length === 0) {
            weekdaysEl.innerHTML = "";
            ["Lun", "Mar", "Mer", "Gio", "Ven", "Sab", "Dom"].forEach(day => {
                weekdaysEl.innerHTML += `<div class="calendar-day-header">${day}</div>`;
            });
        }
        
        // Renderizza giorni del mese
        const daysEl = document.getElementById('publicCalendarDays');
        if (!daysEl) {
            console.error('‚ùå Elemento #publicCalendarDays non trovato');
            return;
        }
        
        daysEl.innerHTML = "";
        
        // Calcola i giorni del mese con allineamento corretto
        const firstDayOfMonth = new Date(year, month, 1);
        const lastDay = new Date(year, month + 1, 0);
        const daysInMonth = lastDay.getDate();
        
        // Calcola il primo giorno della settimana (0 = domenica, 1 = luned√¨, etc.)
        let startDayOfWeek = firstDayOfMonth.getDay();
        
        // Adatta per calendario che inizia con luned√¨ (ISO)
        startDayOfWeek = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;
        
        console.log(`üìÖ Primo giorno del mese: ${firstDayOfMonth.toDateString()}`);
        console.log(`üìä Giorni nel mese: ${daysInMonth}`);
        console.log(`üéØ Giorno della settimana di inizio: ${startDayOfWeek}`);
        
        // Calcola giorni del mese precedente da mostrare
        const prevMonth = month === 0 ? 11 : month - 1;
        const prevYear = month === 0 ? year - 1 : year;
        const daysInPrevMonth = new Date(prevYear, prevMonth + 1, 0).getDate();
        
        // Aggiungi i giorni del mese precedente (grigi)
        for (let i = startDayOfWeek - 1; i >= 0; i--) {
            const dayNumber = daysInPrevMonth - i;
            createPublicCalendarDay(dayNumber, prevYear, prevMonth, true, daysEl);
        }
        
        // Aggiungi i giorni del mese corrente
        for (let day = 1; day <= daysInMonth; day++) {
            createPublicCalendarDay(day, year, month, false, daysEl);
        }
        
        // Calcola quanti giorni del mese successivo aggiungere
        const totalCells = daysEl.children.length;
        const remainingCells = 42 - totalCells; // 6 settimane * 7 giorni - giorni gi√† aggiunti
        
        // Aggiungi i giorni del mese successivo (grigi)
        const nextMonth = month === 11 ? 0 : month + 1;
        const nextYear = month === 11 ? year + 1 : year;
        
        for (let day = 1; day <= remainingCells; day++) {
            createPublicCalendarDay(day, nextYear, nextMonth, true, daysEl);
        }
        
        console.log('‚úÖ Calendario pubblico generato correttamente');
        
    } catch (error) {
        console.error('‚ùå Errore nella generazione del calendario pubblico:', error);
    } finally {
        isCalendarUpdating = false;
    }
}

/**
 * Crea un singolo giorno del calendario pubblico CON BADGE RICORRENTI
 */
function createPublicCalendarDay(dayNumber, year, month, isOtherMonth, container) {
    const dayEl = document.createElement('div');
    const dayDate = new Date(year, month, dayNumber);
    const today = new Date();
    
    // Classi base
    dayEl.className = isOtherMonth ? 
        'public-calendar-day other-month' : 
        'public-calendar-day';
    
    const dateString = `${year}-${String(month + 1).padStart(2, '0')}-${String(dayNumber).padStart(2, '0')}`;
    dayEl.dataset.date = dateString;
    
    // Controlla se √® oggi
    if (!isOtherMonth && 
        dayDate.toDateString() === today.toDateString()) {
        dayEl.classList.add('today');
    }
    
    // Ottieni eventi per questo giorno (solo per giorni del mese corrente)
    let eventsForDay = [];
    let availability = { status: 'available', eventsCount: 0 };
    
    if (!isOtherMonth) {
        eventsForDay = getEventsForDatePublic(dateString);
        availability = checkDayAvailabilityFromEvents(eventsForDay, selectedEvent);
        dayEl.classList.add(`availability-${availability.status}`);
    }
    
    // ‚ú® NUOVO: Contenuto centrale con badge ricorrenti
    let centerContent = '';
    
    if (!isOtherMonth) {
        if (eventsForDay.length === 0) {
            // Nessun evento: indicatore disponibilit√†
            centerContent = `
                <div class="public-day-center available">
                    <div class="availability-indicator">${getAvailabilityIcon(availability.status)}</div>
                </div>
            `;
        } else if (eventsForDay.length === 1) {
            // ‚ú® NUOVO: Un solo evento con badge ricorrente inline
            const event = eventsForDay[0];
            const eventIcon = ICONS[event.evento] || 'üìÖ';
            const isRecurring = event.ricorrente === true || event.ricorrente === 'true';
            
            const recurringBadge = isRecurring ? 
                '<span class="public-recurring-badge" title="Evento Ricorrente">üîÑ</span>' : '';
            
            centerContent = `
                <div class="public-day-center single-event">
                    <div class="public-event-row">
                        <span class="public-event-time">${event.ora}</span>
                        <span class="public-event-icon">${eventIcon}</span>
                        ${recurringBadge}
                    </div>
                    <div class="public-event-type">${getShortEventName(event.evento)}</div>
                    <div class="availability-indicator small">${getAvailabilityIcon(availability.status)}</div>
                </div>
            `;
        } else {
            // ‚ú® NUOVO: Pi√π eventi con indicatore ricorrenti
            const recurringEvents = eventsForDay.filter(e => 
                e.ricorrente === true || e.ricorrente === 'true'
            );
            const hasRecurring = recurringEvents.length > 0;
            
            centerContent = `
                <div class="public-day-center multiple-events">
                    <div class="public-events-count-row">
                        <span class="public-event-count">${eventsForDay.length}</span>
                        ${hasRecurring ? '<span class="public-recurring-badge">üîÑ</span>' : ''}
                    </div>
                    <div class="public-event-label">eventi</div>
                    ${hasRecurring ? `<div class="public-recurring-info">${recurringEvents.length} ricorr.</div>` : ''}
                    <div class="availability-indicator small">${getAvailabilityIcon(availability.status)}</div>
                </div>
            `;
        }
    }
    
    // Struttura HTML del giorno
    dayEl.innerHTML = `
        <div class="day-number">${dayNumber}</div>
        ${centerContent}
    `;
    
    // Event listener per click (solo per giorni del mese corrente e disponibili)
    if (!isOtherMonth && availability.status !== 'occupied') {
        dayEl.addEventListener('click', function(e) {
            // Solo se non si clicka su un evento esistente
            if (!e.target.closest('.public-event-bar') && !e.target.closest('.more-events-indicator')) {
                openDayBookingModal(dateString);
            }
        });
        
        dayEl.style.cursor = 'pointer';
    }
    
    // ‚ú® NUOVO: Tooltip con simboli ricorrenti
    if (!isOtherMonth && eventsForDay.length > 0) {
        const tooltipText = eventsForDay.map(e => {
            const recurringSymbol = (e.ricorrente === true || e.ricorrente === 'true') ? 'üîÑ ' : '';
            return `${recurringSymbol}${e.ora} - ${getEventName(e.evento)}`;
        }).join('\n');
        dayEl.title = tooltipText;
    }
    
    container.appendChild(dayEl);
}

/**
 * Ottiene eventi per una data specifica (calendario pubblico)
 * ‚úÖ AGGIORNATA: Include la stessa logica di ricorrenze virtuali del calendario admin
 */
function getEventsForDatePublic(dateString) {
    try {
        const dataSource = calendarBookings.length > 0 ? calendarBookings : bookings;
        
        // Preparazione delle date di riferimento
        const today = new Date();
        const todayStart = new Date(today.getFullYear(), today.getMonth(), today.getDate());
        const currentDate = new Date(dateString.split('T')[0]);
        
        // 1. Filtra gli eventi singoli (non ricorrenti) che corrispondono alla data richiesta
        const singleEvents = dataSource.filter(b => {
            if (!b.data || b.ricorrente) return false; // Salta se non ha data o se √® una master ricorrente
            
            const eventDate = new Date(b.data.split('T')[0]);
            return eventDate.getTime() === currentDate.getTime();
        });
        
        // 2. ‚úÖ CORREZIONE: Genera ricorrenze virtuali SOLO per le prossime 2 settimane
        const recurringEvents = dataSource
            .filter(b => b.ricorrente) // Prendi solo le prenotazioni "master" ricorrenti
            .filter(masterEvent => {
                const masterDate = new Date(masterEvent.data.split('T')[0]);
                
                // ‚úÖ NUOVO: Controlla se il giorno della settimana corrisponde
                const sameWeekday = currentDate.getDay() === masterDate.getDay();
                
                // ‚úÖ NUOVO: La data corrente deve essere dopo la data master
                const isAfterMaster = currentDate >= masterDate;
                
                // ‚úÖ NUOVO: LIMITE: Solo fino a 2 settimane nel futuro
                const twoWeeksFromToday = new Date(todayStart);
                twoWeeksFromToday.setDate(todayStart.getDate() + 14);
                const isWithinTwoWeeks = currentDate <= twoWeeksFromToday;
                
                // ‚úÖ NUOVO: Non mostrare ricorrenze per date passate
                const isNotPast = currentDate >= todayStart;
                
                return sameWeekday && isAfterMaster && isWithinTwoWeeks && isNotPast;
            })
            .map(masterEvent => {
                // Crea una copia virtuale dell'evento per la data corrente
                return {
                    ...masterEvent, 
                    data: dateString, 
                    id: `${masterEvent.id}-V` // Aggiungi un suffisso per identificarlo come virtuale
                };
            });

        // 3. Unisci eventi singoli e ricorrenze virtuali
        const allEventsForDay = [...singleEvents, ...recurringEvents];

        // 4. Filtra per stato (mostra solo approvati o eventi che non necessitano approvazione)
        return allEventsForDay.filter(event => event.stato !== 'in_attesa' && event.stato !== 'rifiutato');
        
    } catch (error) {
        console.error('Errore getEventsForDatePublic:', error);
        return [];
    }
}

/**
 * Controlla disponibilit√† giorno basata su eventi esistenti
 */
function checkDayAvailabilityFromEvents(eventsForDay, eventType) {
    try {
        const isSpecialEvent = eventType === 'compleanno' || eventType === 'eventi';
        
        // Eventi speciali: controllano tutti gli eventi esistenti
        if (isSpecialEvent) {
            if (eventsForDay.length > 0) {
                return { status: 'occupied', eventsCount: eventsForDay.length };
            } else {
                return { status: 'special', eventsCount: 0 };
            }
        }
        
        // Eventi normali: logica esistente
        const exclusiveEvents = eventsForDay.filter(event => 
            event.evento === 'compleanno' || event.evento === 'eventi'
        );
        
        if (exclusiveEvents.length > 0) {
            return { status: 'occupied', eventsCount: eventsForDay.length };
        }
        
        const conflictingEvents = eventsForDay.filter(event => 
            event.campo === eventType || event.campo === 'entrambi'
        );
        
        if (conflictingEvents.length === 0) {
            return { status: 'available', eventsCount: eventsForDay.length };
        } else {
            return { status: 'partial', eventsCount: eventsForDay.length };
        }
        
    } catch (error) {
        console.error('Errore checkDayAvailabilityFromEvents:', error);
        return { status: 'available', eventsCount: 0 };
    }
}

/**
 * Ottieni icona per stato disponibilit√†
 */
function getAvailabilityIcon(status) {
    const icons = {
        'available': 'üü¢',    // Verde - Disponibile
        'partial': 'üü°',     // Giallo - Parzialmente occupato
        'occupied': 'üî¥',    // Rosso - Non disponibile  
        'special': 'üîµ'      // Celeste - Disponibile per eventi speciali
    };
    return icons[status] || '‚ö™';
}

/**
 * Controlla la disponibilit√† di un giorno per un tipo di evento (funzione legacy)
 */
function checkDayAvailability(dateString, eventType) {
    try {
        const dataSource = calendarBookings.length > 0 ? calendarBookings : bookings;
        const eventsForDay = dataSource.filter(event => {
            const eventDate = event.data ? event.data.split('T')[0] : '';
            return eventDate === dateString && event.stato !== 'rifiutato' && event.stato !== 'in_attesa';
        });
        
        return checkDayAvailabilityFromEvents(eventsForDay, eventType);
        
    } catch (error) {
        console.error('Errore check disponibilit√†:', error);
        return { status: 'available', eventsCount: 0 };
    }
}

/**
 * Apre il modal per prenotazione giorno specifico
 */
function openDayBookingModal(dateString) {
    const dataSource = calendarBookings.length > 0 ? calendarBookings : bookings;
    const eventsForDay = dataSource.filter(event => {
        const eventDate = event.data ? event.data.split('T')[0] : '';
        return eventDate === dateString && event.stato !== 'rifiutato' && event.stato !== 'in_attesa';
    });
    
    const isSpecialEvent = selectedEvent === 'compleanno' || selectedEvent === 'eventi';
    
    // Configura modal
    const modal = document.getElementById('details-modal');
    if (isSpecialEvent) {
        modal.classList.add('special-event-modal');
    } else {
        modal.classList.remove('special-event-modal');
    }
    
    document.getElementById('details-modal-title').innerHTML = 
        `üìÖ ${formatDate(dateString)} - Prenota ${getEventName(selectedEvent)}`;
    
    // Corpo del modal
    const body = document.getElementById('details-modal-body');
    
    // Eventi esistenti (se presenti)
    let existingEventsHtml = '';
    if (eventsForDay.length > 0) {
        existingEventsHtml = `
            <div class="existing-events">
                <h4>üìã Eventi gi√† prenotati:</h4>
                ${eventsForDay.map(event => `
                    <div class="event-summary" style="background: ${getEventColor(event.evento)}; padding: 10px; margin: 5px 0; border-radius: 8px; color: white;">
                        üïê ${event.ora} - ${getEventName(event.evento)} 
                                                 <small>(${(event.ricorrente === true || event.ricorrente === 'TRUE' || event.ricorrente === 'true' || event.ricorrente === 's√¨') && !event.id.includes('-V') ? `${event.nome} üîÑ` : event.nome})</small>
                    </div>
                `).join('')}
            </div>
            <hr style="margin: 20px 0; border: 1px solid #eee;">
        `;
    }
    
    // Form base per tutti
    let formHtml = `
        <div class="inline-booking-form">
            <h4>‚ûï Nuova Prenotazione ${getEventName(selectedEvent)}</h4>
            
            <div class="form-row">
                <div class="form-group">
                    <label>üë§ Nome e Cognome:</label>
                    <input type="text" id="modalNome" required>
                </div>
                <div class="form-group">
                    <label id="modalEmailLabel">üìß Email:</label>
                    <input type="email" id="modalEmail" required>
                </div>
            </div>
            
            <div class="form-row">
                <div class="form-group">
                    <label>üìû Telefono:</label>
                    <input type="tel" id="modalTelefono" required>
                </div>
                <div class="form-group">
                    <label>üïê Ora:</label>
                    <input type="time" id="modalOra" required>
                </div>
            </div>
    `;
    
    // Campi specifici per eventi speciali
    if (isSpecialEvent) {
        formHtml += `
            </div>
            
            <div class="special-event-form">
                <h4>üéâ Dettagli Evento Speciale</h4>
                
                <div class="approval-notice">
                    <strong>‚è≥ Richiede Approvazione</strong><br>
                    La tua richiesta sar√† valutata dall'amministratore entro 24 ore
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label>üë§ Numero persone:</label>
                        <input type="number" id="modalPersonCount" min="1" placeholder="Es. 25" required>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>üé∂ Impianto musicale necessario?</label>
                    <div class="switch-field-inline">
                        <input type="radio" id="modalMusicYes" name="modalMusic" value="S√¨" />
                        <label for="modalMusicYes">S√¨</label>
                        <input type="radio" id="modalMusicNo" name="modalMusic" value="No" checked />
                        <label for="modalMusicNo">No</label>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>ü™ë Tavoli e sedie necessari?</label>
                    <div class="switch-field-inline">
                        <input type="radio" id="modalTablesYes" name="modalTables" value="S√¨" />
                        <label for="modalTablesYes">S√¨</label>
                        <input type="radio" id="modalTablesNo" name="modalTables" value="No" checked />
                        <label for="modalTablesNo">No</label>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>‚ûï Altre richieste particolari:</label>
                    <textarea id="modalOtherRequests" rows="2" placeholder="Specificare qui eventuali esigenze particolari..."></textarea>
                </div>
            </div>
            
            <div class="form-group" style="margin-top: 15px;">
        `;
    } else {
        formHtml += `
            <div class="form-group">
        `;
    }
    
    // Campo note (per tutti)
    formHtml += `
                <label>üìù Note (opzionali):</label>
                <textarea id="modalNote" rows="2" placeholder="Eventuali richieste particolari..."></textarea>
            </div>
            
            <button type="button" class="btn" id="btn-confirm-modal-booking">
                ‚úÖ ${isSpecialEvent ? 'Richiedi' : 'Prenota'} ${getEventName(selectedEvent)}
            </button>
        </div>
    `;
    
    body.innerHTML = existingEventsHtml + formHtml;
    
    // Event listener per conferma
    document.getElementById('btn-confirm-modal-booking').onclick = () => {
        confirmModalBooking(dateString);
    };
    
    modal.style.display = 'block';
    
    // ‚úÖ AGGIUNTA: Aggiorna visibilit√† campo email per admin
    updateModalEmailFieldVisibility();
}

/**
 * Conferma prenotazione da modal calendario
 */
function confirmModalBooking(dateString) {
    // Validazione campi base
    const nome = document.getElementById('modalNome').value.trim();
    const email = document.getElementById('modalEmail').value.trim();
    const telefono = document.getElementById('modalTelefono').value.trim();
    const ora = document.getElementById('modalOra').value;
    const note = document.getElementById('modalNote').value.trim();
    
    if (!nome || !email || !telefono || !ora) {
        showBanner('‚ùå Compila tutti i campi obbligatori', 'error');
        return;
    }
    
    const isSpecialEvent = selectedEvent === 'compleanno' || selectedEvent === 'eventi';
    let finalNote = note;
    
    // Validazione e costruzione note per eventi speciali
    if (isSpecialEvent) {
        const personCount = document.getElementById('modalPersonCount').value;
        const musicOption = document.querySelector('input[name="modalMusic"]:checked').value;
        const tablesOption = document.querySelector('input[name="modalTables"]:checked').value;
        const otherRequests = document.getElementById('modalOtherRequests').value.trim();
        
        if (!personCount) {
            showBanner('‚ùå Inserisci il numero di persone per l\'evento speciale', 'error');
            return;
        }
        
        // Costruisci note dettagliate per eventi speciali
        finalNote = `Dettagli Evento Speciale:\n- Numero Persone: ${personCount}\n- Impianto Musicale: ${musicOption}\n- Tavoli e Sedie: ${tablesOption}`;
        if (otherRequests) {
            finalNote += `\n- Altre Richieste: ${otherRequests}`;
        }
        if (note) {
            finalNote += `\n- Note Aggiuntive: ${note}`;
        }
    }
    
    // ‚úÖ GESTIONE EMAIL ADMIN: Se l'admin √® loggato, usa la sua email
    let emailValue;
    if (isAdminLoggedIn && currentAdminEmail) {
        emailValue = currentAdminEmail;
    } else {
        emailValue = email;
    }
    
    // Crea oggetto prenotazione
    const booking = {
        id: `ANSPI-${generateShortId()}`,
        nome: nome,
        email: emailValue,
        telefono: telefono,
        evento: selectedEvent,
        campo: isSpecialEvent ? 'entrambi' : selectedEvent,
        data: dateString,
        ora: ora,
        note: finalNote,
        ricorrente: false,
        // ‚úÖ Aggiungi adminActionBy se l'admin √® loggato
        adminActionBy: isAdminLoggedIn && currentAdminEmail ? currentAdminEmail : undefined
    };
    
    // Chiudi modal corrente
    closeModal('details-modal');
    
    // Mostra modal di conferma esistente
    currentBooking = booking;
    showConfirmModal(booking, () => finalConfirmBooking('calendar'));
}

/**
 * Gestione eliminazione/riattivazione trigger per calendario pubblico
 */
function handleTriggerStateChangePublic() {
    console.log('üîÑ Gestione cambio stato trigger calendario pubblico...');
    
    setTimeout(() => {
        console.log('üîÑ Reinizializzazione calendario pubblico dopo cambio trigger...');
        
        // Reset completo dello stato
        calendarInitialized = false;
        isCalendarUpdating = false;
        
        // Reinizializza il calendario pubblico
        if (document.getElementById('publicCalendar') && 
            document.getElementById('publicCalendar').style.display !== 'none') {
            initializePublicCalendar();
        }
        
    }, 500);
}

/**
 * Gestione recovery automatico calendario pubblico
 */
function setupPublicCalendarRecovery() {
    // Intercetta le operazioni sui trigger per il calendario pubblico
    const originalMakeRequest = window.makeRequest;
    if (originalMakeRequest && typeof originalMakeRequest === 'function') {
        window.makeRequest = function(...args) {
            const [action] = args;
            
            // Monitora operazioni sui trigger
            if (typeof action === 'string' && 
                (action.includes('trigger') || action.includes('Trigger'))) {
                
                console.log('üîç Operazione trigger rilevata per calendario pubblico:', action);
                
                return originalMakeRequest.apply(this, args)
                    .then(response => {
                        // Se √® un'operazione di successo sui trigger
                        if (response && response.status === 'ok') {
                            console.log('‚úÖ Operazione trigger completata per calendario pubblico');
                            handleTriggerStateChangePublic();
                        }
                        return response;
                    });
            }
            
            return originalMakeRequest.apply(this, args);
        };
    }
}

/**
 * Aggiorna la funzione resetForm per gestire il calendario pubblico
 */
const originalResetFormPublic = window.resetForm;
window.resetForm = function() {
    // Chiama funzione originale se esiste
    if (typeof originalResetFormPublic === 'function') {
        originalResetFormPublic();
    }
    
    // Reset specifico calendario pubblico
    const titleEl = document.getElementById('main-section-title');
    const calendarEl = document.getElementById('publicCalendar');
    
    if (titleEl) titleEl.textContent = 'SCEGLI IL TUO EVENTO';
    if (calendarEl) calendarEl.style.display = 'none';
    
    // ‚úÖ FIX: Reset data calendario pubblico senza bug setMonth()
    const now = new Date();
    publicCalendarDate = new Date(now.getFullYear(), now.getMonth(), 1);
    
    console.log('üîÑ Reset calendario pubblico - data:', publicCalendarDate.toISOString());
    
    // Reset stati
    calendarInitialized = false;
    isCalendarUpdating = false;
};

/**
 * Debug function per calendario pubblico
 */
function debugCalendarPublic() {
    console.log('üîç DEBUG CALENDARIO PUBBLICO:');
    console.log('üìÖ Data corrente:', publicCalendarDate);
    console.log('‚úÖ Inizializzato:', calendarInitialized);
    console.log('üîÑ In aggiornamento:', isCalendarUpdating);
    console.log('üìä Elementi DOM:', {
        calendar: !!document.getElementById('publicCalendar'),
        weekdays: !!document.getElementById('publicCalendarWeekdays'),
        days: !!document.getElementById('publicCalendarDays'),
        title: !!document.getElementById('publicMonthYear'),
        prevBtn: !!document.getElementById('publicPrevMonth'),
        nextBtn: !!document.getElementById('publicNextMonth')
    });
    
    return {
        message: 'Debug calendario pubblico completato',
        data: publicCalendarDate,
        initialized: calendarInitialized,
        updating: isCalendarUpdating
    };
}

// Inizializzazione automatica
document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ Setup calendario pubblico...');
    
    // Setup recovery system
    setupPublicCalendarRecovery();
    
    // Se il calendario pubblico √® gi√† visibile, inizializzalo
    setTimeout(() => {
        const publicCalendar = document.getElementById('publicCalendar');
        if (publicCalendar && publicCalendar.style.display !== 'none') {
            initializePublicCalendar();
        }
    }, 100);
});

// Esponi funzioni di debug
window.debugCalendarPublic = debugCalendarPublic;
window.initializePublicCalendar = initializePublicCalendar;



// =====================
// üéØ AGGIUNGI LE FUNZIONI HELPER QUI SOTTO:
// =====================



/**
 * FUNZIONE HELPER - Controlla disponibilit√† giorno basata su eventi esistenti
 */
function checkDayAvailabilityFromEvents(eventsForDay, eventType) {
    try {
        const isSpecialEvent = eventType === 'compleanno' || eventType === 'eventi';
        
        // Eventi speciali: controllano tutti gli eventi esistenti
        if (isSpecialEvent) {
            if (eventsForDay.length > 0) {
                return { status: 'occupied', eventsCount: eventsForDay.length };
            } else {
                return { status: 'special', eventsCount: 0 };
            }
        }
        
        // Eventi normali: logica esistente
        const exclusiveEvents = eventsForDay.filter(event => 
            event.evento === 'compleanno' || event.evento === 'eventi'
        );
        
        if (exclusiveEvents.length > 0) {
            return { status: 'occupied', eventsCount: eventsForDay.length };
        }
        
        const conflictingEvents = eventsForDay.filter(event => 
            event.campo === eventType || event.campo === 'entrambi'
        );
        
        if (conflictingEvents.length === 0) {
            return { status: 'available', eventsCount: eventsForDay.length };
        } else {
            return { status: 'partial', eventsCount: eventsForDay.length };
        }
        
    } catch (error) {
        console.error('Errore checkDayAvailabilityFromEvents:', error);
        return { status: 'available', eventsCount: 0 };
    }
}

/**
 * FUNZIONE HELPER - Formatta il testo degli eventi (singolare/plurale)
 */
function formatEventsText(count) {
    if (count === 0) {
        return '0 eventi';
    } else if (count === 1) {
        return '1 evento';  // Singolare
    } else {
        return `${count} eventi`;  // Plurale
    }
}
/**
 * Apre il modal per prenotazione giorno specifico
 */
function openDayBookingModal(dateString) {
    const dataSource = calendarBookings.length > 0 ? calendarBookings : bookings;
    const eventsForDay = dataSource.filter(event => {
        const eventDate = event.data ? event.data.split('T')[0] : '';
        return eventDate === dateString && event.stato !== 'rifiutato' && event.stato !== 'in_attesa';
    });
    
    const isSpecialEvent = selectedEvent === 'compleanno' || selectedEvent === 'eventi';
    
    // Configura modal
    const modal = document.getElementById('details-modal');
    if (isSpecialEvent) {
        modal.classList.add('special-event-modal');
    } else {
        modal.classList.remove('special-event-modal');
    }
    
    document.getElementById('details-modal-title').innerHTML = 
        `üìÖ ${formatDate(dateString)} - Prenota ${getEventName(selectedEvent)}`;
    
    // Corpo del modal
    const body = document.getElementById('details-modal-body');
    
    // Eventi esistenti (se presenti)
    let existingEventsHtml = '';
    if (eventsForDay.length > 0) {
        existingEventsHtml = `
            <div class="existing-events">
                <h4>üìã Eventi gi√† prenotati:</h4>
                ${eventsForDay.map(event => `
                    <div class="event-summary" style="background: ${getEventColor(event.evento)}; padding: 10px; margin: 5px 0; border-radius: 8px; color: white;">
                        üïê ${event.ora} - ${getEventName(event.evento)} 
                       
                    </div>
                `).join('')}
            </div>
            <hr style="margin: 20px 0; border: 1px solid #eee;">
        `;
    }
    
    // Form base per tutti
    let formHtml = `
        <div class="inline-booking-form">
            <h4>‚ûï Nuova Prenotazione ${getEventName(selectedEvent)}</h4>
            
            <div class="form-row">
                <div class="form-group">
                    <label>üë§ Nome e Cognome:</label>
                    <input type="text" id="modalNome" required>
                </div>
                <div class="form-group">
                    <label>üìß Email:</label>
                    <input type="email" id="modalEmail" required>
                </div>
            </div>
            
            <div class="form-row">
                <div class="form-group">
                    <label>üìû Telefono:</label>
                    <input type="tel" id="modalTelefono" required>
                </div>
                <div class="form-group">
                    <label>üïê Ora:</label>
                    <input type="time" id="modalOra" required>
                </div>
            </div>
    `;
    
    // Campi specifici per eventi speciali
    if (isSpecialEvent) {
        formHtml += `
            </div>
            
            <div class="special-event-form">
                <h4>üéâ Dettagli Evento Speciale</h4>
                
                <div class="approval-notice">
                    <strong>‚è≥ Richiede Approvazione</strong><br>
                    La tua richiesta sar√† valutata dall'amministratore entro 24 ore
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label>üë§ Numero persone:</label>
                        <input type="number" id="modalPersonCount" min="1" placeholder="Es. 25" required>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>üé∂ Impianto musicale necessario?</label>
                    <div class="switch-field-inline">
                        <input type="radio" id="modalMusicYes" name="modalMusic" value="S√¨" />
                        <label for="modalMusicYes">S√¨</label>
                        <input type="radio" id="modalMusicNo" name="modalMusic" value="No" checked />
                        <label for="modalMusicNo">No</label>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>ü™ë Tavoli e sedie necessari?</label>
                    <div class="switch-field-inline">
                        <input type="radio" id="modalTablesYes" name="modalTables" value="S√¨" />
                        <label for="modalTablesYes">S√¨</label>
                        <input type="radio" id="modalTablesNo" name="modalTables" value="No" checked />
                        <label for="modalTablesNo">No</label>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>‚ûï Altre richieste particolari:</label>
                    <textarea id="modalOtherRequests" rows="2" placeholder="Specificare qui eventuali esigenze particolari..."></textarea>
                </div>
            </div>
            
            <div class="form-group" style="margin-top: 15px;">
        `;
    } else {
        formHtml += `
            <div class="form-group">
        `;
    }
    
    // Campo note (per tutti)
    formHtml += `
                <label>üìù Note (opzionali):</label>
                <textarea id="modalNote" rows="2" placeholder="Eventuali richieste particolari..."></textarea>
            </div>
            
            <button type="button" class="btn" id="btn-confirm-modal-booking">
                ‚úÖ ${isSpecialEvent ? 'Richiedi' : 'Prenota'} ${getEventName(selectedEvent)}
            </button>
        </div>
    `;
    
    body.innerHTML = existingEventsHtml + formHtml;
    
    // Event listener per conferma
    document.getElementById('btn-confirm-modal-booking').onclick = () => {
        confirmModalBooking(dateString);
    };
    
    modal.style.display = 'block';
}

/**
 * Conferma prenotazione da modal calendario
 */
function confirmModalBooking(dateString) {
    // Validazione campi base
    const nome = document.getElementById('modalNome').value.trim();
    const email = document.getElementById('modalEmail').value.trim();
    const telefono = document.getElementById('modalTelefono').value.trim();
    const ora = document.getElementById('modalOra').value;
    const note = document.getElementById('modalNote').value.trim();
    
    if (!nome || !email || !telefono || !ora) {
        showBanner('‚ùå Compila tutti i campi obbligatori', 'error');
        return;
    }
    
    const isSpecialEvent = selectedEvent === 'compleanno' || selectedEvent === 'eventi';
    let finalNote = note;
    
    // Validazione e costruzione note per eventi speciali
    if (isSpecialEvent) {
        const personCount = document.getElementById('modalPersonCount').value;
        const musicOption = document.querySelector('input[name="modalMusic"]:checked').value;
        const tablesOption = document.querySelector('input[name="modalTables"]:checked').value;
        const otherRequests = document.getElementById('modalOtherRequests').value.trim();
        
        if (!personCount) {
            showBanner('‚ùå Inserisci il numero di persone per l\'evento speciale', 'error');
            return;
        }
        
        // Costruisci note dettagliate per eventi speciali
        finalNote = `Dettagli Evento Speciale:\n- Numero Persone: ${personCount}\n- Impianto Musicale: ${musicOption}\n- Tavoli e Sedie: ${tablesOption}`;
        if (otherRequests) {
            finalNote += `\n- Altre Richieste: ${otherRequests}`;
        }
        if (note) {
            finalNote += `\n- Note Aggiuntive: ${note}`;
        }
    }
    
    // Crea oggetto prenotazione
    const booking = {
        id: `ANSPI-${generateShortId()}`,
        nome: nome,
        email: email,
        telefono: telefono,
        evento: selectedEvent,
        campo: isSpecialEvent ? 'entrambi' : selectedEvent,
        data: dateString,
        ora: ora,
        note: finalNote,
        ricorrente: false
    };
    
    // Chiudi modal corrente
    closeModal('details-modal');
    
    // Mostra modal di conferma esistente
    currentBooking = booking;
    showConfirmModal(booking, () => finalConfirmBooking('calendar'));
}

/**
 * Ottieni colore per tipo evento (per modal)
 */
function getEventColor(eventType) {
    const colors = {
        calcetto: 'var(--primary-soft)',
        pallavolo: 'var(--success-soft)',
        compleanno: 'var(--warning-soft)',
        eventi: 'var(--danger-soft)'
    };
    return colors[eventType] || 'var(--secondary-soft)';
}

/**
 * Aggiorna la funzione resetForm per gestire il calendario
 */
const originalResetForm = window.resetForm;
window.resetForm = function() {
    // Chiama funzione originale se esiste
    if (typeof originalResetForm === 'function') {
        originalResetForm();
    }
    
    // Reset specifico calendario pubblico
    const titleEl = document.getElementById('main-section-title');
    const calendarEl = document.getElementById('publicCalendar');
    
    if (titleEl) titleEl.textContent = 'SCEGLI IL TUO EVENTO';
    if (calendarEl) calendarEl.style.display = 'none';
    
    publicCalendarDate = new Date();
};

// =====================
// OTTIMIZZAZIONI MOBILE JAVASCRIPT
// =====================

// Funzione per inizializzare le ottimizzazioni mobile
function initializeMobileOptimizations() {
    if (window.innerWidth <= 768) {
        setupMobileTouchOptimizations();
        setupScrollToTop();
        setupPullToRefresh();
        setupMobileKeyboardHandling();
        setupMobilePerformanceOptimizations();
        setupMobileNavigation();
        setupChromeOptimizations();
    }
}

// Ottimizzazioni touch per mobile
function setupMobileTouchOptimizations() {
    // Previene zoom su doppio tap
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function (event) {
        const now = (new Date()).getTime();
        if (now - lastTouchEnd <= 300) {
            event.preventDefault();
        }
        lastTouchEnd = now;
    }, false);

    // Migliora feedback touch
    const touchElements = document.querySelectorAll('.btn, .event-card, .admin-tab, .calendar-day, .public-calendar-day');
    touchElements.forEach(element => {
        element.addEventListener('touchstart', function() {
            this.style.transform = 'scale(0.98)';
            this.style.transition = 'transform 0.1s ease';
        });
        
        element.addEventListener('touchend', function() {
            this.style.transform = '';
            this.style.transition = '';
        });
    });

    // Gestione swipe per navigazione calendario
    let startX = 0;
    let startY = 0;
    
    document.addEventListener('touchstart', function(e) {
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
    });
    
    document.addEventListener('touchend', function(e) {
        if (!startX || !startY) return;
        
        const endX = e.changedTouches[0].clientX;
        const endY = e.changedTouches[0].clientY;
        
        const diffX = startX - endX;
        const diffY = startY - endY;
        
        // Se lo swipe √® pi√π orizzontale che verticale
        if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 50) {
            const calendarContainer = document.querySelector('.calendar-container');
            if (calendarContainer && calendarContainer.contains(e.target)) {
                if (diffX > 0) {
                    // Swipe sinistra - prossimo mese
                    const nextBtn = document.querySelector('#nextMonthBtn, #publicNextMonth');
                    if (nextBtn) nextBtn.click();
                } else {
                    // Swipe destra - mese precedente
                    const prevBtn = document.querySelector('#prevMonthBtn, #publicPrevMonth');
                    if (prevBtn) prevBtn.click();
                }
            }
        }
        
        startX = 0;
        startY = 0;
    });
}

// Scroll to top button
function setupScrollToTop() {
    // Crea il button scroll to top
    const scrollButton = document.createElement('button');
    scrollButton.className = 'scroll-to-top';
    scrollButton.innerHTML = '‚Üë';
    scrollButton.title = 'Torna in cima';
    document.body.appendChild(scrollButton);
    
    // Mostra/nascondi button in base allo scroll
    window.addEventListener('scroll', function() {
        if (window.pageYOffset > 300) {
            scrollButton.classList.add('visible');
        } else {
            scrollButton.classList.remove('visible');
        }
    });
    
    // Funzione scroll to top
    scrollButton.addEventListener('click', function() {
        window.scrollTo({
            top: 0,
            behavior: 'smooth'
        });
    });
}

// Pull to refresh
function setupPullToRefresh() {
    let startY = 0;
    let currentY = 0;
    let pullDistance = 0;
    let isPulling = false;
    
    // Crea indicatore pull to refresh
    const pullIndicator = document.createElement('div');
    pullIndicator.className = 'pull-refresh-indicator';
    pullIndicator.innerHTML = '‚¨áÔ∏è Trascina per aggiornare';
    document.body.appendChild(pullIndicator);
    
    document.addEventListener('touchstart', function(e) {
        if (window.pageYOffset === 0) {
            startY = e.touches[0].clientY;
            isPulling = true;
        }
    });
    
    document.addEventListener('touchmove', function(e) {
        if (!isPulling) return;
        
        currentY = e.touches[0].clientY;
        pullDistance = currentY - startY;
        
        if (pullDistance > 0 && pullDistance < 150) {
            pullIndicator.style.transform = `translateY(${Math.min(pullDistance - 60, 0)}px)`;
            pullIndicator.style.opacity = Math.min(pullDistance / 150, 1);
        }
    });
    
    document.addEventListener('touchend', function(e) {
        if (!isPulling) return;
        
        if (pullDistance > 100) {
            // Attiva refresh
            pullIndicator.classList.add('active');
            pullIndicator.innerHTML = 'üîÑ Aggiornamento...';
            
            // Simula refresh
            setTimeout(() => {
                loadInitialData(true);
                pullIndicator.classList.remove('active');
                pullIndicator.innerHTML = '‚¨áÔ∏è Trascina per aggiornare';
                pullIndicator.style.transform = 'translateY(-100%)';
                pullIndicator.style.opacity = '0';
            }, 1000);
        } else {
            // Reset indicatore
            pullIndicator.style.transform = 'translateY(-100%)';
            pullIndicator.style.opacity = '0';
        }
        
        isPulling = false;
        pullDistance = 0;
    });
}

// Gestione tastiera mobile
function setupMobileKeyboardHandling() {
    // Previene scroll quando si apre la tastiera
    const inputs = document.querySelectorAll('input, textarea, select');
    inputs.forEach(input => {
        input.addEventListener('focus', function() {
            setTimeout(() => {
                this.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }, 300);
        });
    });
    
    // Gestione submit form con tastiera
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && e.target.tagName === 'INPUT') {
            const form = e.target.closest('form');
            if (form) {
                const submitBtn = form.querySelector('button[type="submit"], .btn');
                if (submitBtn) {
                    e.preventDefault();
                    submitBtn.click();
                }
            }
        }
    });
}

// Ottimizzazioni performance mobile
function setupMobilePerformanceOptimizations() {
    // Lazy loading per immagini
    const images = document.querySelectorAll('img');
    const imageObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const img = entry.target;
                img.src = img.dataset.src || img.src;
                observer.unobserve(img);
            }
        });
    });
    
    images.forEach(img => {
        if (img.dataset.src) {
            imageObserver.observe(img);
        }
    });
    
    // Debounce per eventi frequenti
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }
    
    // Debounce scroll events
    const debouncedScrollHandler = debounce(() => {
        // Gestione scroll ottimizzata
    }, 100);
    
    window.addEventListener('scroll', debouncedScrollHandler);
    
    // Riduce animazioni su mobile
    if (window.innerWidth <= 768) {
        document.documentElement.style.setProperty('--animation-duration', '0.2s');
        document.documentElement.style.setProperty('--transition-duration', '0.2s');
    }
}

// Navigazione mobile ottimizzata
function setupMobileNavigation() {
    // Gestione back button mobile
    const backButtons = document.querySelectorAll('.btn-back');
    backButtons.forEach(btn => {
        btn.addEventListener('click', function(e) {
            e.preventDefault();
            
            // Animazione di uscita
            const container = this.closest('.booking-section, .admin-panel');
            if (container) {
                container.style.transform = 'translateX(100%)';
                container.style.transition = 'transform 0.3s ease';
                
                setTimeout(() => {
                    resetForm();
                    container.style.transform = '';
                    container.style.transition = '';
                }, 300);
            }
        });
    });
    
    // Gestione tab admin su mobile
    const adminTabs = document.querySelectorAll('.admin-tab');
    adminTabs.forEach(tab => {
        tab.addEventListener('click', function() {
            // Feedback visivo per tab selezionata
            adminTabs.forEach(t => t.classList.remove('active'));
            this.classList.add('active');
            
            // Scroll alla tab selezionata
            setTimeout(() => {
                this.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
            }, 100);
        });
    });
}

// Gestione orientamento dispositivo
function handleOrientationChange() {
    const isLandscape = window.innerWidth > window.innerHeight;
    
    if (isLandscape && window.innerWidth <= 768) {
        // Ottimizzazioni per landscape mobile
        document.body.classList.add('mobile-landscape');
    } else {
        document.body.classList.remove('mobile-landscape');
    }
    
    // Ricalcola layout calendario
    if (typeof renderMonthlyCalendar === 'function') {
        renderMonthlyCalendar();
    }
    if (typeof renderPublicCalendar === 'function') {
        renderPublicCalendar();
    }
    
    // Fix per Chrome - riapplica le ottimizzazioni dopo cambio orientamento
    setupChromeOptimizations();
}

// Ottimizzazioni specifiche per Chrome
function setupChromeOptimizations() {
    // Fix per Chrome - Subtitle (box con "Parrocchia Sant'Agostino - ANSPI")
    const subtitle = document.querySelector('.subtitle');
    if (subtitle) {
        subtitle.style.width = '100%';
        subtitle.style.boxSizing = 'border-box';
        subtitle.style.overflowX = 'hidden';
        subtitle.style.overflowWrap = 'break-word';
        subtitle.style.wordWrap = 'break-word';
        subtitle.style.wordBreak = 'break-word';
        subtitle.style.textAlign = 'center';
        subtitle.style.padding = '0 10px';
    }
    
    // Fix per Chrome - Copyright Footer (box nero con diritti riservati)
    const copyrightFooter = document.querySelector('.copyright-footer');
    if (copyrightFooter) {
        copyrightFooter.style.width = '100%';
        copyrightFooter.style.boxSizing = 'border-box';
        copyrightFooter.style.overflowX = 'hidden';
        copyrightFooter.style.overflowWrap = 'break-word';
        copyrightFooter.style.wordWrap = 'break-word';
        copyrightFooter.style.wordBreak = 'break-word';
        
        // Fix per i div interni
        const copyrightDivs = copyrightFooter.querySelectorAll('div');
        copyrightDivs.forEach(div => {
            div.style.width = '100%';
            div.style.boxSizing = 'border-box';
            div.style.overflowX = 'hidden';
        });
        
        // Fix per i paragrafi
        const copyrightParagraphs = copyrightFooter.querySelectorAll('p');
        copyrightParagraphs.forEach(p => {
            p.style.overflowWrap = 'break-word';
            p.style.wordWrap = 'break-word';
            p.style.wordBreak = 'break-word';
            p.style.maxWidth = '100%';
            p.style.boxSizing = 'border-box';
        });
    }
    
    // Fix per Chrome - Info Folder (gi√† esistente, ma lo riapplico per sicurezza)
    const infoFolder = document.querySelector('.info-folder');
    if (infoFolder) {
        infoFolder.style.width = '100%';
        infoFolder.style.boxSizing = 'border-box';
        infoFolder.style.overflowX = 'hidden';
    }
    
    const infoGrid = document.querySelector('.info-grid');
    if (infoGrid) {
        infoGrid.style.width = '100%';
        infoGrid.style.boxSizing = 'border-box';
    }
    
    const infoCards = document.querySelectorAll('.info-card');
    infoCards.forEach(card => {
        card.style.width = '100%';
        card.style.boxSizing = 'border-box';
        card.style.overflowWrap = 'break-word';
        card.style.wordWrap = 'break-word';
        card.style.wordBreak = 'break-word';
    });
    
    // Fix per link lunghi
    const emailLinks = document.querySelectorAll('.email-link');
    const locationLinks = document.querySelectorAll('.location-link');
    
    [...emailLinks, ...locationLinks].forEach(link => {
        link.style.wordBreak = 'break-all';
        link.style.overflowWrap = 'break-word';
        link.style.wordWrap = 'break-word';
        link.style.maxWidth = '100%';
        link.style.display = 'inline-block';
    });
    
    console.log('‚úÖ Ottimizzazioni Chrome applicate');
}

// Gestione connessione mobile
function setupMobileConnectionHandling() {
    let isOnline = navigator.onLine;
    
    function updateConnectionStatus() {
        const wasOnline = isOnline;
        isOnline = navigator.onLine;
        
        if (wasOnline !== isOnline) {
            if (isOnline) {
                showBanner('üì∂ Connessione ripristinata', 'success');
                // Ricarica dati quando torna online
                setTimeout(() => {
                    loadInitialData(true);
                }, 1000);
            } else {
                showBanner('üì∂ Connessione persa - Modalit√† offline', 'warning');
            }
        }
    }
    
    window.addEventListener('online', updateConnectionStatus);
    window.addEventListener('offline', updateConnectionStatus);
    
    // Controlla periodicamente la connessione
    setInterval(() => {
        if (navigator.onLine !== isOnline) {
            updateConnectionStatus();
        }
    }, 5000);
}

// Ottimizzazioni per schermi ad alta densit√†
function setupHighDPIOptimizations() {
    const pixelRatio = window.devicePixelRatio || 1;
    
    if (pixelRatio > 1) {
        // Ottimizza per schermi retina
        document.documentElement.style.setProperty('--border-width', '0.5px');
        document.documentElement.style.setProperty('--shadow-blur', '1px');
    }
}

// Gestione memoria mobile
function setupMobileMemoryOptimizations() {
    // Pulisce cache periodicamente su mobile
    if (window.innerWidth <= 768) {
        setInterval(() => {
            if (cache.bookings && Date.now() - cache.timestamp > 60000) {
                cache.bookings = null;
                cache.timestamp = null;
            }
        }, 30000);
    }
    
    // Gestione event listeners per evitare memory leaks
    const cleanupEventListeners = () => {
        // Rimuove event listeners non necessari
        const elements = document.querySelectorAll('[data-mobile-listener]');
        elements.forEach(el => {
            el.removeAttribute('data-mobile-listener');
        });
    };
    
    window.addEventListener('beforeunload', cleanupEventListeners);
}

// Inizializza tutte le ottimizzazioni mobile
document.addEventListener('DOMContentLoaded', function() {
    initializeMobileOptimizations();
    setupMobileConnectionHandling();
    setupHighDPIOptimizations();
    setupMobileMemoryOptimizations();
    
    // Gestione cambio orientamento
    window.addEventListener('orientationchange', function() {
        setTimeout(handleOrientationChange, 100);
    });
    
    window.addEventListener('resize', debounce(handleOrientationChange, 250));
});

// Funzione debounce utility
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// ... existing code ...
</script>
